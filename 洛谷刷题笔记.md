



| 作者         | Fm                         |
| :----------- | -------------------------- |
| **整理时间** | **2019/11/26**             |
| **主题**     | **9/12-11/26洛谷做题笔记** |
| **工具**     | **Typora**                 |

## 代码规范

1、在所有两目、三目运算符的两边都必须有空格。在单目运算符两端不必空格。但在 “->”、“::”、“.”、“[”、“]”等运算符前后，及“&”（取地址）、“*”（取值）等运 算符之后不得有空格。 

```c++
int n = 0, nTemp;
for (int i = nMaxLine; i <= nMaxLine; i++)
```

2、 for、while、if 等关键字之后应有 1 个空格 。

```c++
if (-2 == n)
```

3、 调用函数、宏时，“(”前不得有空格 

```c++
printf("%d\n", nIndex);
```

#### 命名规范

变量的命名遵从匈牙利记法。即：前缀 + 类型 + 名称。最终的变量名总长不 得超过 32 个英文字符。 

 格式： 

```c++
[m_|s_|g_] type [class name|struct name] variable name 
```

| 字母 | 解释             |
| ---- | ---------------- |
| m_   | 类的成员变量     |
| ms_  | 类的静态成员变量 |
| s_   | 静态全局变量     |
| g_   | 普通全局变量     |

| 类型                   | 缩写 |
| ---------------------- | ---- |
| char, TCHAR            | ch   |
| 字符串                 | sz   |
| bool, BOOL             | b    |
| int, int16,int32,int64 | n    |
| unsigned               | u    |
| long                   | l    |
| unsigned long          | ul   |
| double，float          | f    |
| BYTE                   | by   |
| WORD                   | w    |
| DWORD                  | dw   |
| function               | fn   |
| pointer                | p    |
| object                 | k    |



## 刷题常用

#### 小数类型比较 double

| 传统意义 | 修正写法1       | 修正写法2         |
| -------- | --------------- | ----------------- |
| a == b   | sgn(a - b) == 0 | fabs(a – b) < eps |
| a != b   | sgn(a - b) != 0 | fabs(a – b) > eps |
| a < b    | sgn(a - b) < 0  | a – b < -eps      |
| a <= b   | sgn(a - b) <= 0 | a – b < eps       |
| a > b    | sgn(a - b) > 0  | a – b > eps       |
| a >= b   | sgn(a - b) >= 0 | a – b > -eps      |

#### 二分写法

对其进行分类：
取整方式：向下取整 向上取整 （共2种）
区间开闭：闭区间 左闭右开区间 左开右闭区间 开区间 （共4种）
问题类型：
对于不下降序列a，求最小的i，使得a[i] = key
对于不下降序列a，求最大的i，使得a[i] = key
对于不下降序列a，求最小的i，使得a[i] > key
对于不下降序列a，求最大的i，使得a[i] < key
对于不上升序列a，求最小的i，使得a[i] = key
对于不上升序列a，求最大的i，使得a[i] = key
对于不上升序列a，求最小的i，使得a[i] < key
对于不上升序列a，求最大的i，使得a[i] > key

 算法的目的是解决问题，下面以针对不下降序列a的4个问题为例，给出我认为效率较高，较为简洁的代码。 

 对于不下降序列a，n为序列a元素的个数，key为关键字： 

 **1.求最小的i，使得a[i] = key，若不存在，则返回-1** 

```c++
int binary_search_1(int a[], int n, int key)
{
    int m, l = 0, r = n - 1; // 闭区间[0, n - 1]
    while (l < r)
    {
        m = l + ((r - l) >> 1); // 向下取整
        if (a[m] < key) l = m + 1;
        else r = m;
    }
    if (a[r] == key) return r;
    return -1;
}

```

 **2.求最大的i，使得a[i] = key，若不存在，则返回-1** 

```c++

int binary_search_2(int a[], int n, int key)
{
    int m, l = 0, r = n - 1; // 闭区间[0, n - 1]
    while (l < r)
    {
        m = l + ((r + 1 - l) >> 1); // 向上取整
        if (a[m] <= key) l = m;
        else r = m - 1;
    }
    if (a[l] == key) return l;
    return -1;
}
```

 **3.求最小的i，使得a[i] > key，若不存在，则返回-1** 

```c++

int binary_search_3(int a[], int n, int key)
{
    int m, l = 0, r = n - 1;//闭区间[0, n - 1]
    while (l < r)
    {
        m = l + ((r - l) >> 1);//向下取整
        if (a[m] <= key) l = m + 1;
        else r = m;
    }
    if (a[r] > key) return r;
    return -1;
}
```

 **4.求最大的i，使得a[i] < key，若不存在，则返回-1** 

```c++

int binary_search_4(int a[], int n, int key)
{
    int m, l = 0, r = n - 1;//闭区间[0, n - 1]
    while (l < r)
    {
        m = l + ((r + 1 - l) >> 1);//向上取整
        if (a[m] < key) l = m;
        else r = m - 1;
    }
    if (a[l] < key) return l;
    return -1;
}
```

 下面给出我认为最简洁的代码： 

```c++
// 1.
int ans = std::lower_bound(a, a + n, key) - a;
ans = (ans == n || a[ans] != key) ? -1 : ans;
 
// 2.
int ans = std::upper_bound(a, a + n, key) - a;
ans = (ans == 0 || a[ans - 1] != key) ? -1 : ans - 1;
 
// 3.
int ans = std::upper_bound(a, a + n, key) - a;
ans = (ans == n) ? -1 : ans;
 
// 4.
int ans = std::lower_bound(a, a + n, key) - a;
ans = (ans == 0) ? -1 : ans - 1;
```

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-3 14:40
//	Comment		:	OJ(P1316)二分答案
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		100000000
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

/**
* @brief 用于对二分产生的答案进行检验
*/
bool Check(int* pnSeq, int nA, int nB, int nX)
{
	int nCount = 0;
	int nPre = pnSeq[0];
	for (int i = 1; i < nA; i++)
	{
		if (pnSeq[i] - nPre < nX)
			nCount++;
		else
			nPre = pnSeq[i];
		if (nCount > nA - nB)
			return false;
	}
	return true;
}

int main(int argc, char* argv[])
{
	int			nInputA;
	int			nInputB;
	int*		pnSeq			= NULL;
	int			nLeft;
	int			nRight;
	int			nMid;

	scanf("%d%d", &nInputA, &nInputB);

	pnSeq = (int*)malloc(nInputA * sizeof(int));

	for (int i = 0; i < nInputA; i++)
		scanf("%d", pnSeq + i);

	sort(pnSeq, pnSeq + nInputA);
	nLeft = 1;
	nRight = pnSeq[nInputA - 1] - pnSeq[0];

	while(nLeft <= nRight)
	{
		nMid = (nLeft + nRight) / 2;
		if (Check(pnSeq, nInputA, nInputB, nMid))
			nLeft = nMid + 1;
		else
			nRight = nMid - 1;
	}

	if (Check(pnSeq, nInputA, nInputB, nMid))
		printf("%d", nMid);
	else if (Check(pnSeq, nInputA, nInputB, nRight))
		printf("%d", nRight);
	else
		printf("%d", nLeft - 1);


Exit0:
	return 0;
}
```

#### 差分

差分就是将数列中的每一项分别与前一项数做差，例如：

一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3

这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0）

差分序列最后比原序列多一个数（相当于0减最后一个数）

性质：

1、差分序列求前缀和可得原序列

2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1

3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同

可看例题P3078

#### 分数取模

费马小定理

费马小定理如下：
$$
a^ {p−1} ≡1(mod p)
$$
注意p要为质数

同样我们可以稍作变换： 
$$
a∗a^{p−2}≡1(mod p) 
$$
很明显可以看出，
$$
a^{p−2}
$$
就是a的逆元

```c++
long long power(long long x, long long y, long long mod)
{
  	long long r = 1;
 	while ( y ) 
    {
      	if ( y & 1 ) r = r * x % mod;
      	x = x * x % mod;
      	y >>= 1;
    }
  	return r;
}
```

分数取模

我们要计算分数的模，如下：
$$
x/y≡x∗y^{−1}(mod p)
$$
化简后为：
$$
x / y≡x^{y^{mod−2}}(mod p)
$$
代码也就可以这样计算：

```c++
ans = power(power(x, y, mod), mod-2, mod);
```

#### 方向数组

```c++
int**					ppnGuide = NULL;
ppnGuide = (int**)malloc(4 * sizeof(int*));

for (int i = 0; i < 4; i++)
ppnGuide[i] = (int*)malloc(2 * sizeof(int));

ppnGuide[0][0] = 1; ppnGuide[0][1] = 0;
ppnGuide[1][0] = 0; ppnGuide[1][1] = 1;
ppnGuide[2][0] = -1; ppnGuide[2][1] = 0;
ppnGuide[3][0] = 0; ppnGuide[3][1] = -1;
```

#### GCD

```c++
int CalcGCD(int nA, int nB)
{
	return nB ? CalcGCD(nB, nA % nB) : nA;
}
```

#### DFS

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-8 00:54
//	Comment		:	OJ(P2196)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int				pnAns[30];
int				nC;
map<int, int>	mpNum;
map<int, bool>	mpFlag;

void DFS(int** ppnMat, int* pnPoint, int nN, int nCount, int nSum, int& nMax)
{
	
	if (nMax < nSum)
	{
		nMax = nSum;
		nC = nCount;
		for (int i = 1; i < nCount; i++)
			pnAns[i] = pnPoint[i];
	}
	if (nCount > nN)
		return;
	for (int i = 1; i <= nN; i++)
	{
		if (ppnMat[pnPoint[nCount - 1]][i] && !mpFlag[i])
		{
			mpFlag[i] = 1;
			pnPoint[nCount] = i;
			DFS(ppnMat, pnPoint, nN, nCount + 1, nSum + mpNum[i], nMax);
			mpFlag[i] = 0;
		}
	}
}


int main(int argc, char* argv[])
{
	int				nInputN;
	int				nTemp;

	int*			pnPoint			= NULL;
	int				nAns			= 0;
	int**			ppnMat			= NULL;
	
	scanf("%d", &nInputN);
	for (int i = 1; i <= nInputN; i++)
	{
		scanf("%d", &nTemp);
		mpNum[i] = nTemp;
	}

	ppnMat = (int**)malloc((nInputN + 1) * sizeof(int*));
	pnPoint = (int*)malloc((nInputN + 1) * sizeof(int));
	for (int i = 0; i <= nInputN; i++)
	{
		ppnMat[i] = (int*)malloc((nInputN + 1) * sizeof(int));
		memset(ppnMat[i], 0, (nInputN + 1) * sizeof(int));
	}
	for (int i = 1; i <= nInputN; i++)
		ppnMat[0][i] = 1;

	for (int i = 1; i <= nInputN; i++)
	{
		for (int j = i + 1; j <= nInputN; j++)
		{
			scanf("%d", &nTemp);
			ppnMat[i][j] = nTemp;
		}
	}
	pnPoint[0] = 0;
	DFS(ppnMat, pnPoint, nInputN, 1, 0, nAns);

	for (int i = 1; i < nC; i++)
		printf("%d ", pnAns[i]);
	printf("\n%d\n", nAns);
		
Exit0:

	return 0;
}
```

#### 记忆化搜索

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-10 23:31
//	Comment		:	OJ(P1434)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;
int				nMax	= 0;

int DFS(int** ppnMat, int** ppnAns, int** ppnGuide,
	int nN, int nM, int nNX, int nNY)
{
	if (ppnAns[nNX][nNY])
		return ppnAns[nNX][nNY];
	
	int nAns = 1;
	for (int i = 0; i < 4; i++)
	{
		int nNewX = nNX + ppnGuide[i][0];
		int nNewY = nNY + ppnGuide[i][1];
		if (nNewX < 1 || nNewX > nN)
			continue;
		if (nNewY < 1 || nNewY > nM)
			continue;
		if (ppnMat[nNewX][nNewY] < ppnMat[nNX][nNY])
			nAns = max(nAns, DFS(ppnMat, ppnAns, ppnGuide,
				nN, nM, nNewX, nNewY) + 1);
	}
	ppnAns[nNX][nNY] = nAns;
	nMax = max(nAns, nMax);
	return nAns;
}


int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int**			ppnMat				= NULL;
	int**			ppnAns				= NULL;
	int**			ppnGuide			= NULL;

	ppnGuide = (int**)malloc(3 * sizeof(int*));
	for (int i = 0; i < 4; i++)
		ppnGuide[i] = (int*)malloc(2 * sizeof(int));

	ppnGuide[0][0] = 0; ppnGuide[0][1] = -1;
	ppnGuide[1][0] = -1; ppnGuide[1][1] = 0;
	ppnGuide[2][0] = 0; ppnGuide[2][1] = 1;
	ppnGuide[3][0] = 1; ppnGuide[3][1] = 0;
	scanf("%d%d", &nInputN, &nInputM);

	ppnMat = (int**)malloc((nInputN + 1) * sizeof(int*));
	ppnAns = (int**)malloc((nInputN + 1) * sizeof(int*));
	for (int i = 1; i <= nInputN; i++)
	{
		ppnMat[i] = (int*)malloc((nInputM + 1) * sizeof(int));
		ppnAns[i] = (int*)malloc((nInputM + 1) * sizeof(int));
		memset(ppnAns[i], 0, (nInputM + 1) * sizeof(int));
	}

	for (int i = 1; i <= nInputN; i++)
		for (int j = 1; j <= nInputM; j++)
			scanf("%d", &ppnMat[i][j]);

	for (int i = 1; i <= nInputN; i++)
		for (int j = 1; j <= nInputM; j++)
		{
			DFS(ppnMat, ppnAns, ppnGuide, nInputN, nInputM, i, j);
		}

	printf("%d", nMax);
Exit0:

	return 0;
}
```

#### BFS

```c++
int BFS(int** ppnMat, int nN, int nM, 
	int nStartX, int nStartY, int nEndX, int nEndY)
{
	queue<pair<int, int> >	qBFS;
	pair<int, int>			prTemp;
	pair<int, int>			prNew;
	int						nQSize;
	int						nCount = 0;
	int						nNewX;
	int						nNewY;
	int						nSum = 0;
	int**					ppnFlag = NULL;
	int**					ppnGuide = NULL;

	ppnFlag = (int**)malloc((nN + 1) * sizeof(int*));

	for (int i = 1; i <= nN; i++)
	{
		ppnFlag[i] = (int*)malloc((nM + 1) * sizeof(int));
		memset(ppnFlag[i], 0, (nM + 1) * sizeof(int));
	}

	ppnGuide = (int**)malloc(4 * sizeof(int*));

	for (int i = 0; i < 4; i++)
		ppnGuide[i] = (int*)malloc(2 * sizeof(int));

	ppnGuide[0][0] = 1; ppnGuide[0][1] = 0;
	ppnGuide[1][0] = 0; ppnGuide[1][1] = 1;
	ppnGuide[2][0] = -1; ppnGuide[2][1] = 0;
	ppnGuide[3][0] = 0; ppnGuide[3][1] = -1;

	prTemp.first = nStartX;
	prTemp.second = nStartY;
	ppnFlag[nStartX][nStartY] = 1;
	qBFS.push(prTemp);



	while (!qBFS.empty())
	{
		nCount++;
		nQSize = qBFS.size();
		while (nQSize--)
		{
			prTemp = qBFS.front();
			qBFS.pop();
			for (int i = 0; i < 4; i++)
			{
				nNewX = prTemp.first + ppnGuide[i][0];
				nNewY = prTemp.second + ppnGuide[i][1];

				if (nNewX < 1 || nNewX > nN)
					continue;

				if (nNewY < 1 || nNewY > nM)
					continue;

				if (ppnMat[nNewX][nNewY] || ppnFlag[nNewX][nNewY])
					continue;

				prNew.first = nNewX;
				prNew.second = nNewY;
				if (nNewX == nEndX && nNewY == nEndY)
					return nCount;
				ppnFlag[nNewX][nNewY] = 1;
				qBFS.push(prNew);
			}

		}///while (nQSize--)

	}///while (!qBFS.empty())

	return 0;
}
```

#### Djisteka算法

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-28 23:20
//	Comment		:	OJ(P2299)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int main(int argc, char* argv[])
{
	int			nInputN;
	int			nInputM;
	int**		ppnMat			= NULL;
	unsigned int*		pnDis			= NULL;
	int*		pnFlag			= NULL;
	int			nStart;
	int			nEnd;
	int			nLong;
	int			nMin;
	int			nPoint;
	scanf("%d%d", &nInputN, &nInputM);
	ppnMat = (int**)malloc((nInputN + 1) * sizeof(int*));
	for (int i = 1; i <= nInputN; i++)
	{
		ppnMat[i] = (int*)malloc((nInputN + 1) * sizeof(int));
		memset(ppnMat[i], 0, (nInputN + 1) * sizeof(int));
	}

	pnDis = (unsigned int*)malloc((nInputN + 1) * sizeof(unsigned int));
	memset(pnDis, 127, (nInputN + 1) * sizeof(unsigned int));
	pnFlag = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnFlag, 0, (nInputN + 1) * sizeof(int));

	for (int i = 0; i < nInputM; i++)
	{
		scanf("%d%d%d", &nStart, &nEnd, &nLong);
		if (ppnMat[nStart][nEnd] != 0)
			ppnMat[nStart][nEnd] = min(ppnMat[nStart][nEnd], nLong);
		else
			ppnMat[nStart][nEnd] = nLong;
		ppnMat[nEnd][nStart] = ppnMat[nStart][nEnd];
	}

	for (int i = 2; i <= nInputN; i++)
		if (ppnMat[1][i] != 0)
			pnDis[i] = ppnMat[1][i];

	pnFlag[1] = true;

	for (int i = 2; i <= nInputN; i++)
	{

		nMin = pnDis[0];
		for (int j = 2; j <= nInputN; j++)
		{
			if (pnDis[j] < nMin && pnFlag[j] == false)
			{
				nMin = pnDis[j];
				nPoint = j;
			}
		}

		pnFlag[nPoint] = true;

		for (int j = 2; j <= nInputN; j++)
		{
			if (ppnMat[nPoint][j] != 0)
			{
				if (pnDis[j] > pnDis[nPoint] + ppnMat[nPoint][j] &&
					pnFlag[j] == false)
					pnDis[j] = pnDis[nPoint] + ppnMat[nPoint][j];
			}
		}
	}


	printf("%d", pnDis[nInputN]);

Exit0:

	return 0;
}
```

#### 堆优化Djisteka(邻接表)

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-7 15:23
//	Comment		:	OJ(P4779)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int main(int argc, char* argv[])
{
	int			nInputN;
	int			nInputM;
	map<int, vector<pair<int, int> > >		ppnMat;
	int*		pnDis = NULL;
	int*		pnFlag = NULL;
	int			nStart;
	int			nEnd;
	int			nLong;
	int			nMin;
	int			nPoint;
	int			nS;
	scanf("%d%d%d", &nInputN, &nInputM, &nS);


	pnDis = (int*)malloc((nInputN + 1) * sizeof(int));
	for (int i = 0; i <= nInputN; i++)
		pnDis[i] = 2147483647;

	pnFlag = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnFlag, 0, (nInputN + 1) * sizeof(int));

	for (int i = 0; i < nInputM; i++)
	{
		scanf("%d%d%d", &nStart, &nEnd, &nLong);
		ppnMat[nStart].push_back({ nEnd, nLong });
	}

	

	nStart = nS;
	pnDis[nStart] = 0;
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;
	q.push({ 0, nStart });

	while (!q.empty())
	{
		int nIndex;
		int	nDis;
		nDis = q.top().first;
		nIndex = q.top().second;
		q.pop();
		if (pnFlag[nIndex])
			continue;
		pnFlag[nIndex] = 1;

		for (int j = 0; j < ppnMat[nIndex].size(); j++)
		{
			if (pnDis[ppnMat[nIndex][j].first] > pnDis[nIndex] + ppnMat[nIndex][j].second)
			{
				pnDis[ppnMat[nIndex][j].first] = pnDis[nIndex] + ppnMat[nIndex][j].second;
				if (!pnFlag[ppnMat[nIndex][j].first])
					q.push({ pnDis[ppnMat[nIndex][j].first], ppnMat[nIndex][j].first });
			}
		}

	}
	for (int i = 1; i <= nInputN; i++)
		printf("%d ", pnDis[i]);

Exit0:

	return 0;
}
```

#### 最小生成树

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-16 22:39
//	Comment		:	OJ(P366)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <float.h>

using namespace std;
#define	MAXNUM		1000001
#define	EPS         0.0001
#define MODNUM		100000007


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int**			ppnMat				= NULL;
	unsigned int*	pnDis				= 0;
	int*			pnFlag				= NULL;
	int				nX;
	int				nY;
	int				nW;
	int				nMin;
	int				nPoint				= 1;
	int				nSum				= 0;
	scanf("%d%d", &nInputN, &nInputM);

	ppnMat = (int**)malloc((nInputN + 1) * sizeof(int*));
	pnFlag = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnFlag, 0, (nInputN + 1) * sizeof(int));
	pnDis = (unsigned int*)malloc((nInputN + 1) * sizeof(unsigned int));
	memset(pnDis, 127, (nInputN + 1) * sizeof(int));
	for (int i = 1; i <= nInputN; i++)
	{
		ppnMat[i] = (int*)malloc((nInputN + 1) * sizeof(int));
		memset(ppnMat[i], 0, (nInputN + 1) * sizeof(int));
	}

	for (int i = 0; i < nInputM; i++)
	{
		scanf("%d%d%d", &nX, &nY, &nW);
		if (ppnMat[nX][nY] != 0)
			ppnMat[nX][nY] = min(nW, ppnMat[nX][nY]);
		else
			ppnMat[nX][nY] = nW;
		ppnMat[nY][nX] = ppnMat[nX][nY];
	}

	for (int i = 2; i <= nInputN; i++)
	{
		if (ppnMat[1][i] != 0)
			pnDis[i] = ppnMat[1][i];
	}
		
	pnFlag[1] = true;

	for (int i = 2; i <= nInputN; i++)
	{
		nMin = pnDis[0];
		for (int j = 1; j <= nInputN; j++)
		{
			if (pnDis[j] < nMin && pnFlag[j] == false)
			{
				nMin = pnDis[j];
				nPoint = j;
			}
		}

		pnFlag[nPoint] = true;

		for (int j = 1; j <= nInputN; j++)
		{
			if (ppnMat[nPoint][j] != 0)
			{
				if (pnDis[j] > ppnMat[nPoint][j] && pnFlag[j] == false)
					pnDis[j] = ppnMat[nPoint][j];
			}
		}
	}

	for (int i = 2; i <= nInputN; i++)
	{
		if (pnDis[i] == pnDis[0])
		{
			printf("orz");
			return 0;
		}
		nSum += pnDis[i];
	}

	printf("%d", nSum);

Exit0:

	return 0;
}
```

#### Floyd算法

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-10 23:26
//	Comment		:	OJ(P2910)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>

using namespace std;
#define	MAXNUM		2000001
#define	EPS         0.0001
#define MODNUM		2000001


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	int			nInputN;
	int			nInputM;
	int**		ppnMat			= NULL;
	int*		pnSeq			= NULL;
	int			nAns			= 0;
	scanf("%d%d", &nInputN, &nInputM);

	ppnMat = (int**)malloc((nInputN + 1)* sizeof(int*));
	for (int i = 1; i <= nInputN; i++)
	{
		ppnMat[i] = (int*)malloc((nInputN + 1) * sizeof(int));
		for (int j = 1; j <= nInputN; j++)
			ppnMat[i][j] = 100001;
	}

	pnSeq = (int*)malloc(nInputM * sizeof(int));

	for (int i = 0; i < nInputM; i++)
		scanf("%d", pnSeq + i);

	for (int i = 1; i <= nInputN; i++)
	{
		for (int j = 1; j <= nInputN; j++)
		{
			scanf("%d", &ppnMat[i][j]);
		}
	}

	for (int k = 1; k <= nInputN; k++)
	{
		for (int j = 1; j <= nInputN; j++)
		{
			for (int i = 1; i <= nInputN; i++)
			{
				if (i == j)
					continue;
				if (i == k || k == j)
					continue;
				if (ppnMat[i][j] > ppnMat[i][k] + ppnMat[k][j])
					ppnMat[i][j] = ppnMat[i][k] + ppnMat[k][j];
			}
		}
	}

	for (int i = 1; i < nInputM; i++)
		nAns += ppnMat[pnSeq[i - 1]][pnSeq[i]];


	printf("%d", nAns);
Exit0:

	return 0;
}
```

#### SPFA算法

```c++
void SPFA(int* pnDis, int* pnCount, int* pnFlag, int nStart, int nN,
	vector<pair<int, int> >* ppnMat)
{
	queue<int>	qSPFA;
	int			nTemp;
	for (int i = 0; i <= nN; i++)
		pnDis[i] = 2147483647;
	memset(pnFlag, 0, (nN + 1) * sizeof(int));
	memset(pnCount, 0, (nN + 1) * sizeof(int));

	pnDis[nStart] = 0;
	qSPFA.push(nStart);
	pnFlag[nStart] = 1;

	while (!qSPFA.empty())
	{
		nTemp = qSPFA.front();
		qSPFA.pop();
		pnFlag[nTemp] = 0;
		if (pnCount[nTemp] > nN)
		{
			printf("Forever love");
			exit(0);
		}
		for (int i = 0; i < ppnMat[nTemp].size(); i++)
		{
			if (pnDis[nTemp] + ppnMat[nTemp][i].second < pnDis[ppnMat[nTemp][i].first])
			{
				pnDis[ppnMat[nTemp][i].first] = pnDis[nTemp] + ppnMat[nTemp][i].second;
				if (!pnFlag[ppnMat[nTemp][i].first])
				{
					qSPFA.push(ppnMat[nTemp][i].first);
					pnCount[ppnMat[nTemp][i].first]++;
					pnFlag[ppnMat[nTemp][i].first] = 1;
				}
			}
		}
	}
}
```

#### 拓扑排序

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-15 23:31
//	Comment		:	OJ(P4017)
//
///////////////////////////////////////////


//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	queue<int>			qTopu;
	int					nInputN;
	int					nInputM;
	int					nStrat;
	int					nEnd;
	int					nTemp;
	vector<int>*		vecMat = NULL;
	int*				pnEnter = NULL;
	int*				pnCount = NULL;
	int*				pnQuit = NULL;

	scanf("%d%d", &nInputN, &nInputM);

	vecMat = new vector<int>[nInputN + 1];
	pnEnter = (int*)malloc((nInputN + 1) * sizeof(int));
	pnQuit = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnEnter, 0, (nInputN + 1) * sizeof(int));
	memset(pnQuit, 0, (nInputN + 1) * sizeof(int));
	pnCount = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnCount, 0, (nInputN + 1) * sizeof(int));

	for (int i = 0; i < nInputM; i++)
	{
		scanf("%d%d", &nStrat, &nEnd);
		vecMat[nStrat].push_back(nEnd);
		pnEnter[nEnd]++;
		pnQuit[nStrat]++;
	}

	for (int i = 1; i <= nInputN; i++)
		if (pnEnter[i] == 0)
		{
			pnCount[i]++;
			qTopu.push(i);
		}



	while (!qTopu.empty())
	{
		nTemp = qTopu.front();
		qTopu.pop();
		for (int i = 0; i < vecMat[nTemp].size(); i++)
		{
			pnCount[vecMat[nTemp][i]] =
				(pnCount[vecMat[nTemp][i]] + pnCount[nTemp]) % 80112002;
			pnEnter[vecMat[nTemp][i]]--;
			if (pnEnter[vecMat[nTemp][i]] == 0)
				qTopu.push(vecMat[nTemp][i]);
		}
	}
	nTemp = 0;
	for (int i = 1; i <= nInputN; i++)
		if (pnQuit[i] == 0)
			nTemp = (nTemp + pnCount[i]) % 80112002;


	printf("%d", nTemp % 80112002);

Exit0:
	return 0;
}
```

#### 并查集

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-4 14:40
//	Comment		:	OJ(P3367)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		100000000
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int Fin(int* pnSet, int nNum)
{
	if (pnSet[nNum] == nNum)
		return pnSet[nNum];
	else
		return pnSet[nNum] = 
		Fin(pnSet, pnSet[nNum]);
}
int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int*			pnSet			= NULL;
	int				nInputA;
	int				nInputB;
	int				nInputC;
	scanf("%d%d", &nInputN, &nInputM);

	pnSet = (int*)malloc((nInputN + 1) * sizeof(int));

	for (int i = 1; i <= nInputN; i++)
		pnSet[i] = i;

	for (int i = 0; i < nInputM; i++)
	{
		scanf("%d%d%d", &nInputA, &nInputB, &nInputC);
		if (nInputA == 1)
			pnSet[Fin(pnSet, nInputB)] = Fin(pnSet, nInputC);
		else
		{
			if (Fin(pnSet, nInputB) == Fin(pnSet, nInputC))
				printf("Y\n");
			else
				printf("N\n");
		}
	}
Exit0:
	return 0;
}
```

#### 线段树

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-26 22:22
//	Comment		:	OJ(P3372)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

typedef struct SNode
{
	int			nLeft;
	int			nRight;
	long long	nLazyFlag;
	long long	nNum;
}SNode;


void BuildTree(SNode* psTree, int nNow, int nLeft, 
	int nRight, int* pnSeq)
{
	psTree[nNow].nLazyFlag = 0;
	psTree[nNow].nLeft = nLeft;
	psTree[nNow].nRight = nRight;
	if (nLeft == nRight)
	{
		psTree[nNow].nNum = pnSeq[nLeft];
		return ;
	}
	int		nMid;
	nMid = (nLeft + nRight) / 2;

	BuildTree(psTree, 2 * nNow, nLeft,
		nMid, pnSeq);
	BuildTree(psTree, 2 * nNow + 1, nMid + 1,
		nRight, pnSeq);

	psTree[nNow].nNum = psTree[2 * nNow].nNum + 
		psTree[2 * nNow + 1].nNum;
}

void TransFlag(SNode* psTree, int nNow)
{
	if (psTree[nNow].nLazyFlag == 0)
		return;

	psTree[2 * nNow].nNum += psTree[nNow].nLazyFlag *
		(psTree[2 * nNow].nRight - psTree[2 * nNow].nLeft + 1);
	psTree[2 * nNow].nLazyFlag += psTree[nNow].nLazyFlag;
	psTree[2 * nNow + 1].nNum += psTree[nNow].nLazyFlag *
		(psTree[2 * nNow + 1].nRight - psTree[2 * nNow + 1].nLeft + 1);
	psTree[2 * nNow + 1].nLazyFlag += psTree[nNow].nLazyFlag;
	psTree[nNow].nLazyFlag = 0;
}

void Change(SNode* psTree, int nNow, int nLeft, 
	int nRight, long long nNum)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
	{
		psTree[nNow].nNum += nNum *
			(psTree[nNow].nRight - psTree[nNow].nLeft + 1);
		psTree[nNow].nLazyFlag += nNum;
		return;
	}
	TransFlag(psTree, nNow);

	int		nMid;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		Change(psTree, 2 * nNow, nLeft,nRight, nNum);
	if (nRight > nMid)
		Change(psTree, 2 * nNow + 1, nLeft, nRight, nNum);

	psTree[nNow].nNum = psTree[2 * nNow].nNum + 
		psTree[2 * nNow + 1].nNum;
}

long long Query(SNode* psTree, int nNow, int nLeft, int nRight)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
		return psTree[nNow].nNum;
	TransFlag(psTree, nNow);

	int			nMid;
	long long	llAns = 0;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		llAns += Query(psTree, 2 * nNow, nLeft, nRight);
	if (nRight > nMid)
		llAns += Query(psTree, 2 * nNow + 1, nLeft, nRight);
	return llAns;
}



int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int				nQ;
	int				nLeft;
	int				nRight;
	int				nNum;
	int*			pnSeq			= NULL;
	SNode*			psTree			= NULL;
	
	scanf("%d%d", &nInputN, &nInputM);

	pnSeq = (int*)malloc((nInputN + 1) * sizeof(int));
	psTree = (SNode*)malloc((4 * nInputN + 4) * sizeof(SNode));

	for (int i = 1; i <= nInputN; i++)
		scanf("%d", pnSeq + i);

	BuildTree(psTree, 1, 1, nInputN, pnSeq);


	while (nInputM--)
	{
		scanf("%d", &nQ);
		if (nQ == 1)
		{
			scanf("%d%d%d", &nLeft, &nRight, &nNum);
			Change(psTree, 1, nLeft, nRight, nNum);
		}
		else
		{
			scanf("%d%d", &nLeft, &nRight);
			cout << Query(psTree, 1, nLeft, nRight) << endl;
		}
	}

Exit0:

	return 0;
}
```

####  背包 （混合背包）

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-19 22:44
//	Comment		:	OJ(P2623)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int*			pnBag				= NULL;
	int				nX;
	int				nA;
	int				nB;
	int				nC;
	scanf("%d%d", &nInputN, &nInputM);

	pnBag = (int*)malloc((nInputM + 1) * sizeof(int));
	memset(pnBag, 0, (nInputM + 1) * sizeof(int));

	for (int i = 0; i < nInputN; i++)
	{
		scanf("%d", &nX);
		if (nX == 3)//完全背包
		{
			scanf("%d%d", &nA, &nB);
			for (int j = nB; j <= nInputM; j++)
				pnBag[j] = max(pnBag[j], pnBag[j - nB] + nA);
		}
		if (nX == 2)//多重背包
		{
			scanf("%d%d%d", &nA, &nB, &nC);
			for (int j = nInputM; j >= nB; j--)
			{
				for (int k = 1; k <= min(nC, j / nB); k++)
				{
					if (j - k * nB < 0)
						break;
					pnBag[j] = max(pnBag[j], pnBag[j - k * nB] + nA * k);
				}
			}
		}
		if (nX == 1)
		{
			scanf("%d%d", &nA, &nB);
			for (int j = nInputM; j >= 0; j--)
				for (int k = 1; k <= j; k++)
					pnBag[j] = max(pnBag[j], pnBag[j - k] + k * k * nA - nB * k);
		}
	}

	printf("%d", pnBag[nInputM]);
Exit0:

	return 0;
}
```

#### 快速幂取模

```c++
long long power(long long nX, long long nY, long long nMod)
{
  	long long nR = 1;
 	while ( nY ) 
    {
      	if ( nY & 1 ) nR = nR * nX % nMod;
      	nX = nX * nX % nMod;
      	nY >>= 1;
    }
  	return nR;
}
```

#### 数论

**取余定理**

```c++
1268 mod n=(((1%n*10+2)%n*10+6)%n*10+8)%n
```

**卡特兰数**

*递推式1*
$$
f[n]=f[0]∗f[n−1]+f[1]∗f[n−2]+...+f[n−1]∗f[0](n≥2)
$$
*递推式2*
$$
h[n]=h[n−1]∗(4∗n−2)/(n+1)
$$
*递推式3*
$$
h[n]=C[2n,n]/(n+1)(n=0,1,2,...),C是组合数
$$

$$
C[m,n]=C[m−1,n−1]+C[m−1,n]:且规定：
$$

$$
C[n,0]=1 C[n,n]=1 C[0,0]=1C[n,0]=1C[n,n]=1C[0,0]=1
$$

# **数学相关**

## P2181 对角线（组合数找规律）

**题目**

对于一个N个定点的凸多边形，他的任何三条对角线都不会交于一点。请求图形中对角线交点的个数。

例如，6边形：

![img](https://cdn.luogu.com.cn/upload/pic/6023.png)

**输入格式**

第一行一个n，代表边数。

**输出格式**

第一行输出交点数量

**输入输出样例**

| Input | output |
| ----- | ------ |
| 3     | 0      |
| 6     | 15     |

**说明/提示**

50%的测试数据 3≤N≤100;

100%的测试数据 3≤N≤100000.

**分析**

由于不会有三条对角线交于一点，所以过某一个交点有且只能有２条对角线。

这两条对角线实质上是确定了４个顶点（也可以看做是一个四边形的两条对角线交于一点，求四边形的数量）。

我们只需要确定４个顶点就得到了这个唯一确定的交点。只需要求这样４个顶点的搭配有多少个了。

从ｎ个顶点中取４个出来。

由于改变四个点的顺序不会改变对角线，因此是求的组合而不是排列，也就要除以４！，也就是２４

于是我们就得到了公式 n *(n-1)* (n-2) * (n-3) / 24 原式可以化为n *(n-1) / 2* (n-2) / 3 * (n-3) / 4

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-9-17 19:36
//	Comment		:	OJ(P2181)
//
///////////////////////////////////////////

#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
#include <set>
using namespace std;
#define	MAXNUM		1000000000
#define	EPS         0.0001

typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int main(int argc, char* argv[])
{

	int					nInputN;
	int					nAns;
	scanf("%d", &nInputN);

	nAns = nInputN * (nInputN - 1) / 2 * (nInputN - 2) / 3 * (nInputN - 3) / 4;

	printf("%d", nAns);
Exit0:

	return 0;
}

```

## P2043 质因子分解（素数线性打表）

**题目描述**
对**N!**进行质因子分解。

**输入格式**
输入数据仅有一行包含一个正整数N，N<=10000。

**输出格式**
输出数据包含若干行，每行两个正整数p,a，中间用一个空格隔开。表示N!包含a个质因子p,要求按p的值从小到大输出。

**输入输出样例**

| Input | Output |
| ----- | ------ |
| 10    | 2 8    |
|       | 3 4    |
|       | 5 2    |
|       | 7 1    |

**分析**

1、首先线性打表数组

2、N!可以分解成各项乘积

3、判断每个数的质因子有哪些在对于质因子上++

4、输出

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-9-17 20:29
//	Comment		:	OJ(P2043)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
#include <set>
using namespace std;
#define	MAXNUM		100010
#define	EPS         0.0001

typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int PrimeInit(unsigned int* punSeq, BYTE* pbyIsPrime)
{
	int		nIndex = 0;
	memset(pbyIsPrime, true, MAXNUM * sizeof(BYTE));
    pbyIsPrime[0] = false;
	pbyIsPrime[1] = false;//
	for (int i = 2; i < MAXNUM; i++)
	{
		if (pbyIsPrime[i])
		{
			punSeq[nIndex++] = i;
			for (int j = i * 2; j < MAXNUM; j += i)
				pbyIsPrime[j] = 0;
		}
	}
	return nIndex;
}

int main(int argc, char* argv[])
{
	BYTE*				pbyIsPrime			= NULL;
	unsigned int*		punSeq				= NULL;
	unsigned int*		punCount			= NULL;
	int					nInputN;
	int					nTemp;
	int					nIndex = 0;

	scanf("%d", &nInputN);

	pbyIsPrime = (BYTE*)malloc(MAXNUM * sizeof(BYTE));

	punSeq = (unsigned int*)malloc(MAXNUM * sizeof(unsigned int));

	punCount = (unsigned int*)malloc(MAXNUM * sizeof(unsigned int));

	memset(punCount, 0, MAXNUM * sizeof(unsigned int));

	nIndex = PrimeInit(punSeq, pbyIsPrime);

	for (int i = 2; i <= nInputN; i++)
	{
		nTemp = i;
		for (int j = 0; punSeq[j] <= nTemp && nTemp != 1; j++)
		{
			while (nTemp % punSeq[j] == 0)
			{
				punCount[punSeq[j]]++;
				nTemp /= punSeq[j];
			}
		}
	}///for (int i = 2; i <= nInputN; i++)


	for (int j = 0; punSeq[j] <= nInputN; j++)
		if (punCount[punSeq[j]])
			printf("%d %d\n", punSeq[j], punCount[punSeq[j]]);

Exit0:

	return 0;
}
```
## P5520[yLOI2019] 青原樱（数论）

**题目描述**

扶苏是一个非常喜欢边听古风鸽边写数学题的人，因此这道题其实是个五三原题。

扶苏希望重现青原上樱花盛开的景色，于是他准备了很多**互不相同**樱花树幼苗，准备种成一行。

这一行中，一共有 n*n* 个位置可以种下樱花，而扶苏准备了 *m* 支幼苗。由于樱花盛放时对左右空间需求非常大，所以樱花不能紧挨着种植，也就是任意两支幼苗之间必须至少存在一个不种花的空位置。

按照这种方式种花并不难，但是令扶苏感到好奇的是一共有多少合法的方案让他把这 *m* 支幼苗都种下去。一个方案是合法的当且仅当他满足上一段中叙述的要求。如果我们将花按照 
$$
1, 2, 3 … m
$$
编号，两种方案不同当且仅当被选择种花的位置不同或从左向右数花的编号序列不同。

为了避免输出过大，答案对一个参数 *p* 取模。

**输入格式**

每个输入文件中有且仅有一组测试数据。

测试数据只有一行四个数字，依次代表 type,n,m,p其中 type是一个帮助你判断测试点类型的参数，会在数据范围中说明。

**输出格式**

输出一行一个数字，代表答案对 *p* 取模的结果。

**输入输出样例**

| Input          | output |
| -------------- | ------ |
| 1 3 2 19260718 | 2      |

**分析**

 考虑*m*个花盆之间的花盆：有*n*−*m*个花盆，*n*−*m*个花盆之间有*n*−*m*+1个地方可以放那*m*个花盆。 

方案数是
$$
C^{m}_{n−m+1}
$$
结合题目
$$
(n−m+1)! / m! * (n−m+1−m)!
$$
乘上m
$$
(n−m+1)! / m! * (n−m+1−m)! * m! = (n−m+1)! / (n - 2 * m + 1)!
$$
得
$$
\prod_{i=n - 2 * m + 2}^{n - m + 1} i
$$
**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-23 22:58
//	Comment		:	OJ(P5520)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{

	long long				llInputN;
	long long				llInputM;
	long long				llInputMod;
	long long				llAns				= 1;
	scanf("%lld", &llInputN);
	scanf("%lld%lld%lld", &llInputN, &llInputM, &llInputMod);

	for (int i = llInputN - 2 * llInputM + 2;
		i <= llInputN - llInputM + 1; i++)
		llAns = llAns * i % llInputMod;

	printf("%lld", llAns);
Exit0:

	return 0;
}
```

## P1595 (错排问题)

**题目描述**

某人写了n封信和n个信封，如果所有的信都装错了信封。求所有信都装错信封共有多少种不同情况。

**输入格式**

一个信封数n（n<=20）

**输出格式**

一个整数，代表有多少种情况。

**输入输出样例**

| Input | Output |
| ----- | ------ |
| 2     | 1      |
| 3     | 2      |

**分析**

错排问题指考虑一个有 n*n* 个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。n* 个元素的错排数记为D*(*n*) 。 研究一个排列错排个数的问题，叫做错排问题或称为更列问题。 ---《百度百科》

看上去这就是一个递推问题，那么递推式是如何推出来呢？ 当 *n* 个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用 *D*(*n*) 表示，那么 D*(*n*−1) 就表示 n-1*个编号元素放在 n*−1 个编号位置，各不对应的方法数，其它类推.
第一步，把第 n*个元素放在一个位置，比如位置 k ，一共有 n*−1 种方法；
第二步，放编号为 k* 的元素，这时有两种情况：⑴把它放到位置 n* ，那么，对于剩下的n*−1 个元素，由于第 k* 个元素放到了位置 *n* ，剩下 *n*−2 个元素就有 *D*(*n*−2) 种方法；⑵第 *k* 个元素不把它放到位置 *n* ，这时，对于这 *n*−1 个元素，有 *D*(*n*−1) 种方法；
综上得到
D*(*n*)=(*n*−1)∗(*D*(*n*−2)+*D*(*n*−1))
特殊地，D*(1)=0,*D*(2)=1.

**代码**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-1 19:31
//	Comment		:	OJ(P1595)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;



int main(int argc, char* argv[])
{
	int				nInputN;
	long long*		pllSeq			 = 0;
	scanf("%d", &nInputN);
	pllSeq = (long long*)malloc((nInputN + 1) * sizeof(long long));
	
	if (nInputN == 1)
		printf("0\n");
	else if (nInputN == 2)
		printf("1\n");
	else
	{
		pllSeq[1] = 0;
		pllSeq[2] = 1;
		for (int i = 3; i <= nInputN; i++)
			pllSeq[i] = (i - 1) * (pllSeq[i - 2] + pllSeq[i - 1]);

		printf("%lld", pllSeq[nInputN]);

	}



Exit0:

	return 0;
}
```

## P1044 (卡特兰数) 

**题目背景**

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即pop*p**o**p*（从栈顶弹出一个元素）和push*p**u**s**h*（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

**题目描述**

![img](https://cdn.luogu.com.cn/upload/pic/18.png)

宁宁考虑的是这样一个问题：一个操作数序列，1,2,...,n1,2,...,*n*（图示为1到3的情况），栈A*A*的深度大于n*n*。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的push*p**u**s**h*操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的pop*p**o**p*操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由1 2 3123生成序列2 3 1231的过程。

![img](https://cdn.luogu.com.cn/upload/pic/19.png)

（原始状态如上图所示）

你的程序将对给定的n*n*，计算并输出由操作数序列1,2,…,n1,2,…,*n*经过操作可能得到的输出序列的总数。

**输入格式**

输入文件只含一个整数n(1≤n≤18)*n*(1≤*n*≤18)

**输出格式**

输出文件只有11行，即可能输出序列的总数目

**输入输出样例**

| Input | Output |
| ----- | ------ |
| 3     | 5      |

**分析**

建立数组f。f[i]表示i个数的全部可能性。

f[0] = 1, f[1] = 1; //当然只有一个

设 x 为当前出栈序列的最后一个，则x有n种取值

由于x是最后一个出栈的，所以可以将已经出栈的数分成两部分

1. 比x小
2. 比x大

比x小的数有x-1个，所以这些数的全部出栈可能为f[x-1]

比x大的数有n-x个，所以这些数的全部出栈可能为f[n-x]

这两部分互相影响，所以一个x的取值能够得到的所有可能性为f[x-1] * f[n-x]

另外，由于x有n个取值，所以

ans = f[0]*f[n-1] + f[1]*f[n-2] + ... + f[n-1]*f[0];

这，就是传说中的卡特兰数

**代码**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-2 21:01
//	Comment		:	OJ(P1044)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;



int main(int argc, char* argv[])
{
	int				nInputN;
	int*			pnAns			= NULL;
	scanf("%d", &nInputN);

	pnAns = (int*)malloc((nInputN + 1) * sizeof(int));
	pnAns[0] = 1;
	pnAns[1] = 1;
	for (int i = 2; i <= nInputN; i++)
		for (int j = 0; j < i; j++)
			pnAns[i] += pnAns[j] * pnAns[i - j - 1];

	printf("%d", pnAns[nInputN]);
Exit0:

	return 0;
}
```

## P2807 三角形计数(数论)

**题目背景**

三角形计数(triangle) 递推

**题目描述**

把大三角形的每条边n等分，将对应的等分点连接起来（连接线分别平行于三条边），这样一共会有多少三角形呢？编程来解决这个问题。

**输入格式**

第一行为整数t(≤100)，表示测试数据组数；接下来t行，每行一个正整数n(≤500)。

**输出格式**

对于每个n，输出一个正整数，表示三角形个数。

**输入输出样例**

| Input | Output |
| ----- | ------ |
| 3     | 1      |
| 1     | 5      |
| 2     | 13     |
| 3     |        |

**分析**

思路：把大三角形看成等边三角形，先考虑正着放的，再考虑倒着放的

我们把底边在第 *i* 条线段上的三角形成为在第 *i* 层

正着放（边长为 *i*）：

三角形个数最少的层数：第 *i* 层，共有 11 个

三角形个数最多的层数：第 *n* 层，共有 *n*−*k*+1 个

正着放**边长为 i** 的小三角形有 1+2+……+(*n*−*i*+1) 个

边长 *i* 的范围：1,2,3……*n*

倒着放（边长为 *j* ）：

三角形个数最少的层数：第 *j* 层，共有一个

三角形个数最多的层数：第*n*−*j* 层：共有 (*n*−*j*)−*j*+1 个

倒着放**边长为j** 的小三角形有1+2+……+(*n*−2∗*j*+1)个

边长 *j* 的范围：1,2,3……*n*/2, *n*/2向下取整 （因为是倒着放的，所以最底下要留出一半的高度）

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-2 23:34
//	Comment		:	OJ(P2807)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		100000000
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int main(int argc, char* argv[])
{
	int					nInputT;
	int					nInputN;
	int					nAns			= 0;
	int*				pnSeq			= NULL;

	scanf("%d", &nInputT);
	pnSeq = (int*)malloc(501 * sizeof(int));
	pnSeq[0] = 0;
	for (int i = 1; i <= 500; i++)
		pnSeq[i] = pnSeq[i - 1] + i;
	for (int i = 0; i < nInputT; i++)
	{
		scanf("%d", &nInputN);
		for (int j = 1; j <= nInputN; j++)
			nAns += pnSeq[nInputN - j + 1];

		for (int j = 1; j <= nInputN / 2; j++)
			nAns += pnSeq[nInputN - j * 2 + 1];
		
		printf("%d\n", nAns);

		nAns = 0;
	}

Exit0:
	return 0;
}
```

## 

## P3152 正整数序列（数论）

**题目描述**

kkk制造了一个序列，这个序列里的数全是由正整数构成的。你别认为她的数列很神奇——其实就是1, 2, …, n而已。当然，n是给定的。kkk的同学lzn认为0是一个好数字（看上去很饱满有木有），所以他机智的趁kkk不在把这个序列全变成了0（其实只是准备窝）~

可是kkk突然回来了！于是lzn的计划破灭了。但是他并不甘心，就和kkk说：我可以每次从这个序列中选取一些数，然后一起减去一个相同的数（当然也是正整数）。然后经过有(wu)限(qiong)次这样的操作后，这个序列就可以全变成0。

kkk当然不信咯，于是lzn就求出了他最少要做几次这样的操作，才能使这个序列全部变成0。

**输入格式**

一个正整数n

**输出格式**

最少操作次数

如果无解输出-1

**输入输出样例**

| Input | OutPut |
| ----- | ------ |
| 2     | 2      |

**分析**

包含贪心。

如本来序列1,2,3,4,5,6,7,8,9;

可将a[i]>=5的全-5，得1,2,3,4,0,1,2,3,4

再将a[i]>=3的全-3，得1,2,0,1,0,1,2,0,1

再将a[i]>=2的全-2，得1,0,0,1,0,1,0,0,1

最后将a[i]>=1的全-1，得0,0,0,0,0,0,0,0,0

共4次。

于是发现，我们可以这样操作，每次找到当前序列中最大的数maxn，

将所有a[i]>=maxn/2+1的全减maxn/2+1,直到序列全为零。

通过找规律，可得：当序列长度为n时，最少需log2(n)+1次操作；

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-7 23:11
//	Comment		:	OJ(P3152)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		150
#define	EPS         0.0001
#define MODNUM		1000000007ll


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;



int main(int argc, char* argv[])
{
	int							nInputN;
	int							nInputM;
	long long					llTemp = 1;

	scanf("%d", &nInputN);

	printf("%d\n", int(log10(nInputN) / log10(2) + 1));

Exit0:

	return 0;
}
```

## P1287 盒子与球（数论 斯特林数）

**题目描述**

现有r个互不相同的盒子和n个互不相同的球，要将这n个球放入r个盒子中，且不允许有空盒子。问有多少种方法？

例如：有2个不同的盒子（分别编为1号和2号）和3个不同的球（分别编为1、2、3号），则有6种不同的方法：

![img](https://cdn.luogu.com.cn/upload/pic/92.png)

**输入格式**

两个整数，n和r，中间用空格分隔。（0≤n, r≤10）

**输出格式**

仅一行，一个整数（保证在长整型范围内）。表示n个球放入r个盒子的方法。

**输入输出样例**

| Input | Output |
| ----- | ------ |
| 3 2   | 6      |

**分析**

[stirling数（斯特林数） - 百度百科](https://baike.baidu.com/item/斯特林数/4938529?fr=aladdin)

> 设有n个不同的球，分别用b1,b2,……bn表示。从中取出一个球bn，bn的放法有以下两种：
>
> 1) bn独自占一个盒子；那么剩下的球只能放在m-1个盒子中，方案数为：f(n-1, m-1)
>
> 2) bn与别的球共占一个盒子；那么可以事先将b1,b2,……bn-1这n-1个球放入m个盒子中，然后再将球bn可以放入其中一个盒子中，方案数为 :m*f(n-1,m)
>
> 3) 边界条件

1. > a) 盒子数 < 0（盒子数“超支”），不成一种方案。

2. > b) 球数 < 盒子数（盒子数“超支”），不成一种方案。

3. > c) 球数 = 盒子数（正好），为一种方案。

现有r个互不相同的盒子!!!

不同!!!

所以还要乘上盒子的排列组合

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-7 23:05
//	Comment		:	OJ(P1287)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		150
#define	EPS         0.0001
#define MODNUM		1000000007ll


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

long long Ans(long long llN, long long llM)
{
	if (llM <= 0 || llN < llM)
		return 0;
	else if (llN == llM)
		return 1;
	else
		return Ans(llN - 1, llM - 1) + Ans(llN - 1, llM) * llM;
}


int main(int argc, char* argv[])
{
	int							nInputN;
	int							nInputM;
	long long					llTemp = 1;

	scanf("%d%d", &nInputN, &nInputM);

	for (int i = 1; i <= nInputM; i++)
		llTemp *= i;


	printf("%lld\n", Ans(nInputN, nInputM) * llTemp);

Exit0:

	return 0;
}
```

## P5436 【XR-2】缘分(数论)

**题目描述**

一禅希望知道他和师父之间的缘分大小。可是如何才能知道呢？

一禅想了个办法，他先和师父约定一个正整数 n*n*，接着他们各自在心里想一个不超过 n*n* 的正整数。

一禅认为，他和师父心里想的这两个数的**最小公倍数**越大，则意味着他和师父之间的缘分越大。

师父觉得这个办法很合适，不过他想知道这两个数的最小公倍数最大会是多少。

师父的数学不太好，于是问一禅。一禅也觉得这个问题很困难，他希望你能告诉他答案。

**输入格式**

本题有多组数据

第一行一个正整数 T*T*，表示数据组数。

接下来的 T*T* 行，每行一个正整数 n*n*，表示一禅和师父约定的正整数。

**输出格式**

对每组数据，一行一个正整数，表示答案。

**输入输出样例**

| Input | Output |
| ----- | ------ |
| 1     | 6      |
| 3     |        |

**分析**

**题意**：给定一个正整数 *n*，对于两数 *a* 和 *b* (1≤*a*,*b*≤*n*)，求出max{ *l**c**m*(*a*,*b*) } .

结论题。

显然对于相邻两数 x*−1 和 x* ，它们是互质的。

对于此题，lcm(n-1,n)即为小于等于 *n* 范围内两数的最大*l**c**m* .

因此最终解即为 n*×(*n−1) .

特别地，当 *n*=1 时，结果应为 1 .

注意最终解可能超过 *i**n**t* 范围。

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-7 22:46
//	Comment		:	OJ(P5436)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		150
#define	EPS         0.0001
#define MODNUM		1000000007ll


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;



int main(int argc, char* argv[])
{
	int							nInputN;
	int*						pnSeq;
	int							nAns			 = 0;
	int							nTemp;
	scanf("%d", &nInputN);

	while (nInputN--)
	{
		scanf("%d", &nTemp);
		if (nTemp == 1)
			printf("1\n");
		else
			printf("%lld\n", nTemp * (nTemp - 1L));
	}

Exit0:

	return 0;
}
```

## P1226 （快速幂取模）

输入b，p，k的值，求b^p mod k的值。其中b，p，k*k为长整型数。

**输入格式**

三个整数b,p,k.

**输出格式**

输出“b^p mod k=s”

s为运算结果

**输入输出样例**

| Input  | Output       |
| ------ | ------------ |
| 2 10 9 | 2^10 mod 9=7 |

**代码**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-1 16:48
//	Comment		:	OJ(P1042)
//
///////////////////////////////////////////

#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>
#include <sstream>

using namespace std;
#define	MAXNUM		100000000
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int Mode(int a, int b, int mode)
{
	int sum = 1;
	a = a % mode;

	while (b > 0) {
		if (b % 2 == 1)		//判断是否是奇数，是奇数的话将多出来的数事先乘如sum
			sum = (sum * a) % mode;

		b /= 2;
		a = (a * a) % mode;// 不断的两两合并再取模，减小a和b的规模
	}
	return sum;
}

int main(int argc, char* argv[])
{
	int				nInputB;
	int				nInputP;
	int				nInputK;

	scanf("%d%d%d", &nInputB, &nInputP, &nInputK);

	if (nInputP == 0)
		if (nInputK == 1)
			printf("%d^%d mod %d=0\n", nInputB, nInputP, nInputK);
		else
			printf("%d^%d mod %d=1\n", nInputB, nInputP, nInputK);
	else
		printf("%d^%d mod %d=%d\n", nInputB, nInputP, nInputK,
			Mode(nInputB, nInputP, nInputK));
Exit0:
	return 0;
}
```

## 

## P2524 棋盘问题（可用公式纯暴力）

**题目描述**
设有一个N×M方格的棋盘(1≤N≤100,1≤M≤100)(1≤N≤100,1≤M≤100)

求出该棋盘中包含有多少个正方形、多少个长方形（不包括正方形）。

例如：当 N=2, M=3N=2,M=3时： ![img](https://cdn.luogu.com.cn/upload/pic/310.png)

正方形的个数有8个：即边长为1的正方形有6个；

边长为2的正方形有2个。

长方形的个数有10个：

即

2×1的长方形有4个 ![img](https://cdn.luogu.com.cn/upload/pic/311.png)

1×2的长方形有3个 ![img](https://cdn.luogu.com.cn/upload/pic/312.png)

3×1的长方形有2个 ![img](https://cdn.luogu.com.cn/upload/pic/313.png)

3×2的长方形有1个 ![img](https://cdn.luogu.com.cn/upload/pic/314.png)

如上例：输入：2,3

输出：8,10

**输入格式**
N,MN,M

**输出格式**
正方形的个数与长方形的个数

**输入输出样例**

| Input | Output |
| ----- | ------ |
| 2 3   | 8 10   |

**分析**

可以枚举数据量比较小

有公式方法。

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-9-17 21:04
//	Comment		:	OJ(P1548)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
#include <set>
using namespace std;
#define	MAXNUM		100010
#define	EPS         0.0001


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int				nCountRec			= 0;
	int				nCountSqu			= 0;

	scanf("%d%d", &nInputN, &nInputM);
	for (int i = 0; i <= nInputN; i++)
	{
		for (int j = 0; j <= nInputM; j++)
		{
			for (int k = i + 1; k <= nInputN; k++)
			{
				for (int l = j + 1; l <= nInputM; l++)
				{
					if ((k - i) != (l - j))
						nCountRec++;
					else
						nCountSqu++;
				}
			}
		}///for (int j = 1; j <= nInputM; j++)
	}///for (int i = 1; i <= nInputN; i++)

	printf("%d %d", nCountSqu, nCountRec);

Exit0:

	return 0;
}
```

## P1296(暴力)

**题目描述**
在你的养牛场，所有的奶牛都养在一排呈直线的牛栏中。一共有n头奶牛，其中第i头牛在直线上所处的位置可以用一个整数坐标pi(0<=pi<=10^8)来表示。在无聊的日子里，奶牛们常常在自己的牛栏里与其它奶牛交流一些八卦新闻。每头奶牛发出的声音响度是一样的，而由于声波的能量衰减，某头奶牛发出的声音只能被与它距离不超过d(0<=d<=10^4)的奶牛所听到，这样这对奶牛就称为可以相互交流的。现在给出所有奶牛的位置和声音所能传播的最远距离d，请你编个程序来计算你的养牛场里究竟有多少对可以相互交流的奶牛。

**输入格式**
第1行包含两个整数n,d。

第2行包含n个整数，每个整数都是一个坐标pi，描述一头奶牛在直线上的位置。

**输出格式**
一个数，表示养牛场中可以相互交流奶牛的对数。

**输入输出样例**

| Input          | Output |
| -------------- | ------ |
| 5 10           | 4      |
| 10 12 16 37 40 |        |

**说明/提示**
数据规模

对于40%的数据，n<=10^3；

对于100%的数据，n<=10^6。

**分析**

暴力

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-9-16 20:51
//	Comment		:	OJ(P1296)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
#include <set>
using namespace std;
#define	MAXNUM		1000001
#define	EPS         0.0001

typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int CalcGCD(int a, int b)
{
	return b ? CalcGCD(b, a%b) : a;
}

int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputD;
	int				nAnsSum			= 0;
	int*			pnSeq			= NULL;

	scanf("%d%d", &nInputN, &nInputD);

	pnSeq = (int*)malloc(nInputN * sizeof(int));

	for (int i = 0; i < nInputN; i++)
		scanf("%d", pnSeq + i);
		
	sort(pnSeq, pnSeq + nInputN);

	for (int i = 0; i < nInputN; i++)
		for (int j = i + 1; j < nInputN; j++)
			if (pnSeq[j] - pnSeq[i] <= nInputD)
				nAnsSum++;
			else
			    break;

	printf("%d", nAnsSum);

Exit0:

	return 0;
}
```

# **动态规划**

## P1510 精卫填海(背包)

**问题描述**

发鸠之山，其上多柘木。有鸟焉，其状如乌，文首，白喙，赤足，名曰精卫，其名自詨。是炎帝之少女，名曰女娃。女娃游于东海，溺而不返，故为精卫。常衔西山之木石，以堙于东海。——《山海经》

精卫终于快把东海填平了！只剩下了最后的一小片区域了。同时，西山上的木石也已经不多了。精卫能把东海填平吗？

事实上，东海未填平的区域还需要至少体积为v的木石才可以填平，而西山上的木石还剩下n块，每块的体积和把它衔到东海需要的体力分别为k和m。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为c。

**输入格式**

输入文件的第一行是三个整数：v、n、c。

从第二行到第n+1行分别为每块木石的体积和把它衔到东海需要的体力。

**输出格式**

输出文件只有一行，如果精卫能把东海填平，则输出她把东海填平后剩下的最大的体力，否则输出’Impossible’（不带引号）。

**输入输出样例**

| input    | output     |
| -------- | ---------- |
| 100 2 10 | 0          |
| 50 5     |            |
| 50 5     |            |
| 10 2 1   | Impossible |
| 50 5     |            |
| 10 2     |            |

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-19 23:20
//	Comment		:	OJ(P1510)
//
///////////////////////////////////////////


//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int main(int argc, char* argv[])
{
	int					nInputV;
	int					nInputN;
	int					nInputC;
	int*				pnBagForm				= NULL;
	int					nV;
	int					nC;
	scanf("%d%d%d", &nInputV, &nInputN, &nInputC);

	pnBagForm = (int*)malloc((nInputC + 1) * sizeof(int));
	memset(pnBagForm, 0, (nInputC + 1) * sizeof(int));

	for (int i = 0; i < nInputN; i++)
	{
		scanf("%d%d", &nV, &nC);
		for (int j = nInputC; j >= nC; j--)
			pnBagForm[j] = max(pnBagForm[j], pnBagForm[j - nC] + nV);
	}

	if (pnBagForm[nInputC] < nInputV)
		printf("Impossible");
	else
	{
		for (int i = 1; i <= nInputC; i++)
		{
			if (pnBagForm[i] >= nInputV)
			{
				printf("%d", nInputC - i);
				return 0;
			}
		}
	}



Exit0:
	return 0;
}
```



## P2871 (背包)

**题目描述**

Bessie has gone to the mall's jewelry store and spies a charm bracelet. Of course, she'd like to fill it with the best charms possible from the N (1 ≤ N ≤ 3,402) available charms. Each charm i in the supplied list has a weight Wi (1 ≤ Wi ≤ 400), a 'desirability' factor Di (1 ≤ Di ≤ 100), and can be used at most once. Bessie can only support a charm bracelet whose weight is no more than M (1 ≤ M ≤ 12,880).

Given that weight limit as a constraint and a list of the charms with their weights and desirability rating, deduce the maximum possible sum of ratings.

有N件物品和一个容量为V的背包。第i件物品的重量是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。

**输入格式**

\* Line 1: Two space-separated integers: N and M

\* Lines 2..N+1: Line i+1 describes charm i with two space-separated integers: Wi and Di

第一行：物品个数N和背包大小M

第二行至第N+1行：第i个物品的重量C[i]和价值W[i]

**输出格式**

\* Line 1: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints

输出一行最大价值。

**输入输出样例**

| Input | Output |
| ----- | ------ |
| 4 6   | 23     |
| 1 4   |        |
| 2 6   |        |
| 3 12  |        |
| 2 7   |        |

**分析**

0-1背包问题。

问题描述
有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？

为方便讲解和理解，下面讲述的例子均先用具体的数字代入，即：eg：number＝4，capacity＝8

i（物品编号）	1	2	3	4
w（体积）	2	3	4	5
v（价值）	3	4	5	6

总体思路
根据动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出01背包问题的最优解以及解组成，然后编写代码实现。

动态规划的原理
动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。

最优性原理是动态规划的基础，最优性原理是指“多阶段决策过程的最优决策序列具有这样的性质：不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言，其后各阶段的决策序列必须构成最优策略”。

背包问题的解决过程
在解决问题之前，为描述方便，首先定义一些变量：Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。

1、建立模型，即求max(V1X1+V2X2+…+VnXn)；

2、寻找约束条件，W1X1+W2X2+…+WnXn<capacity；

3、寻找递推关系式，面对当前商品有两种可能性：

包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；
还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。
其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；

由此可以得出递推关系式：

j<w(i)      V(i,j)=V(i-1,j)
j>=w(i)     V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝
这里需要解释一下，为什么能装的情况下，需要这样求解（这才是本问题的关键所在！）：

可以这么理解，如果要到达V(i,j)这一个状态有几种方式？

肯定是两种，第一种是第i件商品没有装进去，第二种是第i件商品装进去了。没有装进去很好理解，就是V(i-1,j)；装进去了怎么理解呢？如果装进去第i件商品，那么装入之前是什么状态，肯定是V(i-1,j-w(i))。由于最优性原理（上文讲到），V(i-1,j-w(i))就是前面决策造成的一种状态，后面的决策就要构成最优策略。两种情况进行比较，得出最优。

4、填表，首先初始化边界条件，V(0,j)=V(i,0)=0；

![img](https://img-blog.csdn.net/20180814153341616?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNzMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

然后一行一行的填表：

如，i=1，j=1，w(1)=2，v(1)=3，有j<w(1)，故V(1,1)=V(1-1,1)=0；
又如i=1，j=2，w(1)=2，v(1)=3，有j=w(1),故V(1,2)=max｛ V(1-1,2)，V(1-1,2-w(1))+v(1) ｝=max｛0，0+3｝=3；
如此下去，填到最后一个，i=4，j=8，w(4)=5，v(4)=6，有j>w(4)，故V(4,8)=max｛ V(4-1,8)，V(4-1,8-w(4))+v(4) ｝=max｛9，4+6｝=10……
所以填完表如下图：

![img](https://img-blog.csdn.net/20180814153424308?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNzMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

5、表格填完，最优解即是V(number,capacity)=V(4,8)=10。

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-9-20 21:53
//	Comment		:	OJ(P2871)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		7010
#define	EPS         0.0001
#define MODNUM		1000000007ll


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	int			nInputN;
	int			nInputM;
	int			nC;
	int			nW;
	int*		pnBagFrom		= NULL;

	scanf("%d%d", &nInputN, &nInputM);

	pnBagFrom = (int*)malloc((nInputM + 1) * sizeof(int));
	memset(pnBagFrom, 0, (nInputM + 1) * sizeof(int));

	for (int i = 0; i < nInputN; i++)
	{
		scanf("%d%d", &nC, &nW);

		for (int j = nInputM; j >= 0; j--)
			if (nC <= j)
				pnBagFrom[j] = max(pnBagFrom[j], pnBagFrom[j - nC] + nW);

	}
	printf("%d", pnBagFrom[nInputM]);


Exit0:

	return 0;
}
```

## P1192(动态规划)

**题目描述**

有*N*级的台阶，你一开始在底部，每次可以向上迈最多*K*级台阶（最少11级），问到达第*N*级台阶有多少种不同方式。

**输入格式**

两个正整数N，K。

**输出格式**

一个正整数，为不同方式数，由于答案可能很大，你需要输出a**n**s mod 100003后的结果。
**输入输出样例**

| Input | Output |
| ----- | ------ |
| 5 2   | 8      |

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-9-25 16:01
//	Comment		:	OJ(P1192)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;






int main(int argc, char* argv[])
{

	int				nInputN;
	int				nInputK;
	int*			pnSeq			= NULL;

	scanf("%d%d", &nInputN, &nInputK);
	
	pnSeq = (int*)malloc((nInputN + 1) * sizeof(int));

	for (int i = 1; i <= nInputK; i++)
		pnSeq[i] = 1;
	for (int i = nInputK + 1; i <= nInputN; i++)
		pnSeq[i] = 0;



	for (int i = 1; i <= nInputN; i++)
	{
		for (int j = 1; j <= nInputK; j++)
		{
			if (i - j <= 0)
				break;
			pnSeq[i] += pnSeq[i - j];
			pnSeq[i] %= MODNUM;
		}
	}

	printf("%d", pnSeq[nInputN]);


Exit0:

	return 0;
}
```

## P2370 yyy2015c01的U盘(背包)

**题目描述**

你找yyy2015c01借到了这个高端的U盘，拷贝一些重要资料，但是你发现这个U盘有一些问题：

1、这个U盘的传输接口很小，只能传输大小不超过L的文件

2、这个U盘容量很小，一共只能装不超过S的文件

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值Vi，你希望备份的文件总价值不小于 p

但是很快你发现这是不可能的，因为yyy2015c01的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在U盘中文件的总大小不能超过U盘容量

现在问题来了：你想知道，在满足U盘中文件价值之和 不小于 p时，最小需要多大的接口

**输入格式**

第1行，三个正整数 n, p, S 分别表示 文件总数， 希望最小价值p，硬盘大小

接下来n行

每行两个正整数 Wi, Vi 表示 第i个文件的大小，和价值

**输出格式**

一共1行，输出一个正整数表示最小需要的接口大小

如果无解输出 “No Solution!” 不含引号

**输入输出样例**

| Input   | OutPut       |
| ------- | ------------ |
| 3 3 5   | 2            |
| 2 2     |              |
| 1 2     |              |
| 3 2     |              |
| 2 3 505 | 500          |
| 1 2     |              |
| 500 1   |              |
| 4 5 6   | No Solution! |
| 5 1     |              |
| 5 2     |              |
| 5 3     |              |
| 1 1     |              |

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-17 00:38
//	Comment		:	OJ(P2370)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <bitset>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int main(int argc, char* argv[])
{
	int				nN;
	int				nP;
	int				nS;
	int*			pnBag			= NULL;
	pair<int, int>*	prTemp			= NULL;
	scanf("%d%d%d", &nN, &nP, &nS);
	prTemp = new pair<int, int>[nN];
	pnBag = (int*)malloc((nS + 1) * sizeof(int));
	memset(pnBag, 0, (nS + 1) * sizeof(int));

	for (int i = 0; i < nN; i++)
		scanf("%d%d", &prTemp[i].first, &prTemp[i].second);

	sort(prTemp, prTemp + nN);

	for (int i = 0; i < nN; i++)
	{
		for (int j = nS; j >= prTemp[i].first; j--)
		{
			pnBag[j] = max(pnBag[j], pnBag[j - prTemp[i].first] + prTemp[i].second);
			if (pnBag[nS] >= nP)
			{
				printf("%d", prTemp[i].first);
				return 0;
			}
		}
	}

	printf("No Solution!");
	
Exit0:

	return 0;
}
```

## P1358 扑克牌(动态规划找规律)

**题目描述**

组合数学是数学的重要组成部分，是一门研究离散对象的科学，它主要研究满足一定条件的组态（也称组合模型）的存在、计数以及构造等方面的问题。组合数学的主要内容有组合计数、组合设计、组合矩阵、组合优化等。

随着计算机科学的日益发展，组合数学的重要性也日渐凸显，因为计算机科学的核心内容是使用算法处理离散数据。

今天我们来研究组合数学中的一个有趣的问题，也是一个简单的计数问题：

从一副含有n(n≤10000)张的扑克牌[显然每张扑克牌都不相同]中，分给m(m≤100)个人，第i个人得到ai (0≤ai≤100)张牌，求一共有几种分法，这个数可能非常大，请输出此数模10007后的结果。

**输入格式**

第一行两个整数 为 n m

第二行 m个整数 ai

**输出格式**

此数模10007后的结果

**输入输出样例**

| Input                                 | Output |
| ------------------------------------- | ------ |
| 5 2                                   | 20     |
| 3 1                                   |        |
| 20 19                                 | 8707   |
| 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 |        |

**分析**

i为总张数，o为取的张数

![img](https://s2.ax1x.com/2019/07/05/ZdeCyF.png)

通过画图找规律，我们得到状态转移方程

```
f[i][o]=f[i-1][o-1]+f[i-1][o];
```

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-14 22:14
//	Comment		:	OJ(P1718)
//
///////////////////////////////////////////

#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <float.h>

using namespace std;
#define	MAXNUM		1000001
#define	EPS         0.0001
#define MODNUM		100000007


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int**			ppnDp			= NULL;
	int				nTemp;
	int				nSum			= 1;

	scanf("%d%d", &nInputN, &nInputM);

	ppnDp = (int**)malloc((nInputN + 1) * sizeof(int*));

	for (int i = 0; i <= nInputN; i++)
		ppnDp[i] = (int*)malloc(101 * sizeof(int));
	memset(ppnDp[0], 0, 101 * sizeof(int));

	for (int i = 0; i <= nInputN; i++)
	{
		ppnDp[i][0] = 1;
		if (i < 101)
			ppnDp[i][i] = 1;
	}

	for (int i = 1; i <= nInputN; i++)
		for (int j = 1; j <= 100; j++)
			ppnDp[i][j] = (ppnDp[i - 1][j] + ppnDp[i - 1][j - 1]) % 10007;

	for (int i = 0; i < nInputM; i++)
	{
		scanf("%d", &nTemp);
		nSum *= ppnDp[nInputN][nTemp];
		nSum %= 10007;
		nInputN -= nTemp;
	}

	printf("%d", nSum);

Exit0:

	return 0;
}
```

# **序列**

## P2008 大朋友的数字(最长不下降子序列)

**题目描述**

有一批大朋友（年龄15岁以上），他们每人手上拿着一个数字，当然这个数字只有1位，也就是0到9之间。每个大朋友的分数为在他之前的最长不下降子序列中所有数之和。（这个序列必须以它作为结尾！）如有多个最长不下降子序列，那么取编号字典序最小的。现在告诉你有n个大朋友，以及他们各自的数字，请你求出他们每个人的分数。

**输入格式**

输入文件为bignum.in。

第一行，1个数n。

第二行，n个数，分别表示每个人的数字。

**输出格式**

输出文件为bignum.out。

一行，n个数，分别表示每个人的分数。

**输入输出样例**

| Input     | Output      |
| --------- | ----------- |
| 5         |             |
| 1 2 5 3 4 | 1 3 8 6 10  |
| 5         |             |
| 1 7 5 9 6 | 1 8 6 17 12 |

**分析**

 利用最长不下降子序列的最朴素算法加以改造求得

一. 最容易想到的最暴力的方法
对这个序列中的每一个数的”有”和”无”分两种情况讨论. 代码实现上就是递归.

时间复杂度就是O(2^n)

代码实现上较为简单. 不展示

二. 第二种方法是O(n^2)的DP方法
动态规划的问题是无后效性的, 每个问题都可以分解为更小的子问题, 从而求解.

这道题也不例外.

这个序列的每一个数为止都有一个解, 作为子问题的解. 后面的问题的解就是从这些子问题的最优解继承过来的.

so, 给这个序列的解建立数组dp[n], 0 - n分别是截止到Ai的解.

当下一个数要加入来的时候, 有两种情况

前面的数都比当前数更大, 因此以这个数为止的最长不下降子序列的长度就是1. 遍历到第一个数的情况也包含在内.

前面的数有不比当前数大的, 那么这个数的结果dp[i] = max(dp[i], dp[j] + 1). 这个过程遍历前面所有数的dp[j]进行比较.

最后的答案就是所有dp[i]里面的最大值.

这种方法的时间复杂度是O(n^2), 可以看到相比于前面暴力递归的方法有了极大的进步.

代码通过样例, 但不一定能过题, 请谨慎使用.
三. O(nlogn)方法, 维护单调数组
这个方法也是DP方法

时间复杂度可以从O(n^2)降到O(n log n).

我们从最长上升子序列的角度来探讨

假设对一个序列n[1…9] = {2 1 5 3 6 4 8 9 7}, 维护一个单调数组, 使得这个数组为最长上升子序列. 设这个数组为d[ ].

对n[1] = 2, 使得d[1] = 2;

对n[2] = 1, 因为1比2小, 所以修改d[1]的值, 使其为1

对n[3] = 5, 5比1大, 所以len++, d[2] = 5

对n[4] = 3, 3比1大比5小, 所以替换掉5, 使d[2] = 3

对n[5] = 6, 6比d[2]大, 所以len++, d[3] = 6

对n[6] = 4, 4比3大比6小, 所以替换掉6, 使d[3] = 4

对n[7] = 8, 8比4大, 所以len++, 使d[4] = 8

对n[8] = 9, 9比8大, 所以len++, 使d[5] = 9

对n[9] = 7, 7比4大比8小, 所以替换掉8, 使d[4] = 7.

至此这个序列遍历完了, 最小的长度也出来了. 最后的序列是1 3 4 7 9, len = 5

仔细琢磨会觉得, 如最后一步操作, 为什么后面的7反而到他前面的8, 9的前面去了. 其实仔细一想并无问题, 因为即使7出现在前面, 它并不影响最终结果, 因为我们已经得出最后结果就是len, 而以7为结尾的最长序列在该题中是len - 1, 如果后面还有序列, 那么这里把7替换掉8会使得当前状态更优, 因为这样的修改是不会改变当前结果的, 但是确实后续最优状态的基础. 而这道题的动态规划思想就是这样, 不断地获取最优状态.

经过前面的分析我们也许会发现, 这个DP的过程无法存储中间结果, 也就是说我们只能知道最长的子序列是多长, 而无法得到是哪个序列. 可谓是有利有弊.

利用我们维护的数组的单调性, 我们可以用二分法查找这个比当前数更大数的位置, 从而方便的实现替换.

所以时间复杂度为O(n log n).

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-14 23:43
//	Comment		:	OJ(P2008)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <float.h>

using namespace std;
#define	MAXNUM		2000001
#define	EPS         0.0001
#define MODNUM		100000007


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	int				nInputN;
	int*			pnSeq		= NULL;
	int*			pnCount		= NULL;
	int*			pnAns		= NULL;
	scanf("%d", &nInputN);
	pnSeq = (int*)malloc(nInputN * sizeof(int));
	
	pnCount = (int*)malloc(nInputN * sizeof(int));
	memset(pnCount, 0, nInputN * sizeof(int));
	pnAns = (int*)malloc(nInputN * sizeof(int));
	memset(pnAns, 0, nInputN * sizeof(int));
	for (int i = 0; i < nInputN; i++)
		scanf("%d", pnSeq + i);

	for (int i = 0; i < nInputN; i++)
	{
		pnCount[i] = 1;
		for (int j = 0; j <= i - 1; j++)
		{
			if (pnSeq[j] <= pnSeq[i] && pnCount[j] + 1 > pnCount[i])
			{
				pnCount[i] = pnCount[j] + 1;
				pnAns[i] = pnAns[j];
			}
		}
		pnAns[i] += pnSeq[i];
	}
	for (int i = 0; i < nInputN; i++)
	{

		printf("%d ", pnAns[i]);
	}

Exit0:

	return 0;
}
```

## P2543 [AHOI2004]奇怪的字符串 （最长公共子序列）

**题目描述**

![img](https://cdn.luogu.com.cn/upload/pic/1654.png)

**输入格式**

输入文件中包含两个字符串X和Y。当中两字符串非0即1。序列长度均小于9999。

**输出格式**

X和Y的最长公共子序列长度。

**输入输出样例**

| Input                    | Output |
| ------------------------ | ------ |
| 01010101010 00000011111  | 6      |
| 01011 010010101111111111 | 5      |

**分析**

***最长公共子序列***
最长公共子序列的问题很简单，就是在两个字符串中找到最长的子序列，这里明确两个含义：

子串：表示连续的一串字符 。
子序列：表示不连续的一串字符。
所以这里要查找的是不连续的最长子序列，

**①最优子结构**

设 X=(x1,x2,.....xn) 和 Y={y1,y2,.....ym} 是两个序列，将 X 和 Y 的最长公共子序列记为LCS(X,Y)

找出LCS(X,Y)就是一个**最优化问题**。因为，我们需要找到X 和 Y中**最长的**那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。

**1）如果 xn=ym**，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)

LCS(Xn-1，Ym-1)就是原问题的**一个**子问题。为什么叫子问题？因为它的规模比原问题小。（小一个元素也是小嘛....）

为什么是最优的子问题？因为我们要找的是Xn-1 和 Ym-1 的最长公共子序列啊。。。最长的！！！换句话说，就是最优的那个。（这里的最优就是最长的意思）

**2）如果xn != ym**，这下要麻烦一点，因为它产生了**两个**子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)

因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长**公共**子序列中的元素嘛。（都不相等了，怎么公共嘛）。

LCS(Xn-1，Ym)表示：最长公共序列可以在(x1,x2,....x(n-1)) 和 (y1,y2,...yn)中找。

LCS(Xn，Ym-1)表示：最长公共序列可以在(x1,x2,....xn) 和 (y1,y2,...y(n-1))中找。

求解上面两个子问题，得到的公共子序列谁最长，那谁就是 LCS（X,Y）。用数学表示就是：

LCS=max{LCS(Xn-1，Ym)，LCS(Xn，Ym-1)}

由于条件 1) 和 2) 考虑到了所有可能的情况。因此，**我们成功地把原问题 转化 成了 三个规模更小的子问题。**

 

**②重叠子问题**

重叠子问题是啥？就是说原问题 转化 成子问题后， 子问题中有相同的问题。咦？我怎么没有发现上面的三个子问题中有相同的啊？？？？

OK，来看看，原问题是：LCS(X,Y)。子问题有 ❶LCS(Xn-1，Ym-1)  ❷LCS(Xn-1，Ym)   ❸LCS(Xn，Ym-1)

初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：

第二个子问题：LCS(Xn-1，Ym) 就包含了：问题❶LCS(Xn-1，Ym-1)，为什么？

因为，当Xn-1 和 Ym 的最后一个元素不相同时，我们又需要将LCS(Xn-1，Ym)进行分解：分解成：LCS(Xn-1，Ym-1) 和 LCS(Xn-2，Ym)

也就是说：在子问题的**继续**分解中，有些问题是重叠的。

***动态规划***
这里为什么要使用动态规划可以说一下，简单来说动态规划是为了降低时间复杂度的一种算法，申请一个额外空间，来保存每一个步骤的结果，最后从这些结果中找到最优的解。

这里有个问题就是：一般来说，当前的最优解，只与当前时刻和上一时刻有关系，和其他时刻没有关系，这样才能让动态规划发生作用，降低复杂度。

***分析LCS***
其实LCS看起来很麻烦，找不到思路，如果暴力破解可能要O(n^4)了，而这个题目使用动态规划的思想也非常简单，为何相比之前的问题不好找思路呢？

是因为之前的动态规划问题例如：背包问题，生产线问题，都是一维数组空间内的结果，规划到一个线性时间内，而这个题目需要O(m*n)的时间复杂度和空间复杂度。

所以其实就是进行m*n次对比，每次保存当前的最优解，就可以了。

***代码实现分析***
这里有个问题，就是我们需要的结果仅仅是长度？ 还是包括这个序列串一起输出。

看下面图：

 ![img](https://img-blog.csdn.net/20150824000143524) 

这里可以看到，我们构造的一个i*j的矩阵，这个矩阵里的内容不但包括数值（当前结果的最优解），还包括一个方向箭头，这个代表了我们回溯的时候，需要行走的方向。

所以我们这里保存两个值，可以使用两个二维矩阵，也可以使用一个结构体矩阵。

解法分析
其实这个题目在动态规划来理解，也非常简单。一个状态转移函数。

 ![img](https://img-blog.csdn.net/20150825231108446) 

这个非常好理解，其中一个字符串为0的时候，那么肯定是0了。

当两个字符相等的时候，这个时候很好理解，举例来说：

abcd 和 adcd,在遍历c的时候，发现前面只有a相等了，也就是1.
那么c相等，也就是abc和adc在匹配的时候，一定比ab和ad的长度大1，这个1就是c相等么。也就是相等的时候，是比

```
c[i-1][j-1]
```

大1的。

下一个更好理解了，如果不相等，肯定就是找到上一个时刻对比最大的么。

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-31 18:12
//	Comment		:	OJ(P2543)
//
///////////////////////////////////////////


//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	string			sA;
	string			sB;
	int**			ppnDp		= NULL;
	cin >> sA >> sB;

	sA = " " + sA;
	sB = " " + sB;

	ppnDp = (int**)malloc((sA.length() + 1) * sizeof(int*));

	for (int i = 0; i <= sA.length(); i++)
	{
		ppnDp[i] = (int*)malloc((sB.length() + 1) * sizeof(int));
		memset(ppnDp[i], 0, (sB.length() + 1) * sizeof(int));
	}

	for (int i = 1; i < sA.length(); i++)
		for (int j = 1; j < sB.length(); j++)
		{
			if (sA[i] == sB[j])
				ppnDp[i][j] = ppnDp[i - 1][j - 1] + 1;
			else
				ppnDp[i][j] = max(ppnDp[i][j - 1], ppnDp[i - 1][j]);
		}
	printf("%d", ppnDp[sA.length() - 1][sB.length() - 1]);
		





Exit0:
	return 0;
}
```

## P3078 扑克牌型Poker Hands（差分）

**题目描述**

Bessie and her friends are playing a unique version of poker involving a deck with N (1 <= N <= 100,000) different ranks, conveniently numbered 1..N (a normal deck has N = 13). In this game, there is only one type of hand the cows can play: one may choose a card labeled i and a card labeled j and play one card of every value from i to j. This type of hand is called a "straight".

Bessie's hand currently holds a_i cards of rank i (0 <= a_i <= 100000). Help her find the minimum number of hands she must play to get rid of all her cards.

一个牛有N堆牌，每堆排数量不等。一只牛一次可以将第i张到第j张各打一张出去，问最少几次打完

**输入格式**

\* Line 1: The integer N.

\* Lines 2..1+N: Line i+1 contains the value of a_i.

**输出格式**

\* Line 1: The minimum number of straights Bessie must play to get rid of all her cards.

**输入输出样例**

| Input | Output |
| ----- | ------ |
| 5     | 6      |
| 2     |        |
| 4     |        |
| 1     |        |
| 2     |        |
| 3     |        |

**分析**

首先把序列差分一下，a[i]=w[i]-w[i-1]*a*[*i*]=*w*[*i*]−*w*[*i*−1]，那么[l,r][*l*,*r*]区间减就变成a[r+1]++,a[l]--*a*[*r*+1]++,*a*[*l*]−−

然后最终要求a全变成0

而
$$
\sum_1^{n+1} a_i=0
$$
每一个大于0的*a*i*后面一定存在一个小于0的a*j

显然l和r的选取是任意的，那么我们直接选择所有大于0的a_i*a**i*使其减一，故答案就是差分后所有正数的和

区间问题转化成差分往往会大大简化问题

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-18 23:36
//	Comment		:	OJ(P3078)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <float.h>

using namespace std;
#define	MAXNUM		1000001
#define	EPS         0.0001
#define MODNUM		100000007


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	int					nInputN;
	int*				pnSeq			= NULL;
	int*				pnDis			= NULL;
	long long			llAns			= 0;
	
	scanf("%d", &nInputN);

	pnSeq = (int*)malloc((nInputN + 1) * sizeof(int));
	pnDis = (int*)malloc((nInputN + 1) * sizeof(int));
	pnSeq[0] = 0;
	for (int i = 1; i <= nInputN; i++)
		scanf("%d", pnSeq + i);

	for (int i = 1; i <= nInputN; i++)
		pnDis[i] = pnSeq[i] - pnSeq[i - 1];
	for (int i = 1; i <= nInputN; i++)
		if (pnDis[i] > 0)
			llAns += pnDis[i];

	printf("%lld", llAns);

Exit0:

	return 0;
}
```

# **线段树**

## P3372 【模板】线段树 1

**题目描述**

如题，已知一个数列，你需要进行下面两种操作：

1.将某区间每一个数加上x

2.求出某区间每一个数的和

**输入格式**

第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。

第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。

接下来M行每行包含3或4个整数，表示一个操作，具体如下：

操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k

操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和

**输出格式**

输出包含若干行整数，即为所有操作2的结果。

**输入输出样例**

| Input     | Output |
| --------- | ------ |
| 5 5       | 11     |
| 1 5 4 2 3 | 8      |
| 2 2 4     | 20     |
| 1 2 3 2   |        |
| 2 3 4     |        |
| 1 1 5 1   |        |
| 2 1 4     |        |

**分析**

来首先简介一下线段树，就一个数据结构，类似本题，可以维护区间加，区间查找等操作，其余还有区间乘，区间最大值，甚至最大连续子段和等等好多操作……

貌似长这样：（图片来自互联网） ![img](http://p5.so.qhimgs1.com/t019e2060978883abeb.png)

***线段树的存储***

```c++
typedef struct SNode
{
	int			nLeft;
	int			nRight;
	long long	nLazyFlag;
	long long	nNum;
}SNode;
```

***建树***

```c++
void BuildTree(SNode* psTree, int nNow, int nLeft, 
	int nRight, int* pnSeq)
{
	psTree[nNow].nLazyFlag = 0;
	psTree[nNow].nLeft = nLeft;
	psTree[nNow].nRight = nRight;
	if (nLeft == nRight)
	{
		psTree[nNow].nNum = pnSeq[nLeft];
		return ;
	}
	int		nMid;
	nMid = (nLeft + nRight) / 2;

	BuildTree(psTree, 2 * nNow, nLeft,
		nMid, pnSeq);
	BuildTree(psTree, 2 * nNow + 1, nMid + 1,
		nRight, pnSeq);

	psTree[nNow].nNum = psTree[2 * nNow].nNum + 
		psTree[2 * nNow + 1].nNum;
}
```

***懒标记***

```c++
void TransFlag(SNode* psTree, int nNow)
{
	if (psTree[nNow].nLazyFlag == 0)
		return;

	psTree[2 * nNow].nNum += psTree[nNow].nLazyFlag *
		(psTree[2 * nNow].nRight - psTree[2 * nNow].nLeft + 1);
	psTree[2 * nNow].nLazyFlag += psTree[nNow].nLazyFlag;
	psTree[2 * nNow + 1].nNum += psTree[nNow].nLazyFlag *
		(psTree[2 * nNow + 1].nRight - psTree[2 * nNow + 1].nLeft + 1);
	psTree[2 * nNow + 1].nLazyFlag += psTree[nNow].nLazyFlag;
	psTree[nNow].nLazyFlag = 0;
}
```

***修改区间值***

```c++
void Change(SNode* psTree, int nNow, int nLeft, 
	int nRight, long long nNum)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
	{
		psTree[nNow].nNum += nNum *
			(psTree[nNow].nRight - psTree[nNow].nLeft + 1);
		psTree[nNow].nLazyFlag += nNum;
		return;
	}
	TransFlag(psTree, nNow);

	int		nMid;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		Change(psTree, 2 * nNow, nLeft,nRight, nNum);
	if (nRight > nMid)
		Change(psTree, 2 * nNow + 1, nLeft, nRight, nNum);

	psTree[nNow].nNum = psTree[2 * nNow].nNum + 
		psTree[2 * nNow + 1].nNum;
}
```

***查询区间值***

```c++
long long Query(SNode* psTree, int nNow, int nLeft, int nRight)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
		return psTree[nNow].nNum;
	TransFlag(psTree, nNow);

	int			nMid;
	long long	llAns = 0;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		llAns += Query(psTree, 2 * nNow, nLeft, nRight);
	if (nRight > nMid)
		llAns += Query(psTree, 2 * nNow + 1, nLeft, nRight);
	return llAns;
}
```

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-26 22:22
//	Comment		:	OJ(P3372)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

typedef struct SNode
{
	int			nLeft;
	int			nRight;
	long long	nLazyFlag;
	long long	nNum;
}SNode;


void BuildTree(SNode* psTree, int nNow, int nLeft, 
	int nRight, int* pnSeq)
{
	psTree[nNow].nLazyFlag = 0;
	psTree[nNow].nLeft = nLeft;
	psTree[nNow].nRight = nRight;
	if (nLeft == nRight)
	{
		psTree[nNow].nNum = pnSeq[nLeft];
		return ;
	}
	int		nMid;
	nMid = (nLeft + nRight) / 2;

	BuildTree(psTree, 2 * nNow, nLeft,
		nMid, pnSeq);
	BuildTree(psTree, 2 * nNow + 1, nMid + 1,
		nRight, pnSeq);

	psTree[nNow].nNum = psTree[2 * nNow].nNum + 
		psTree[2 * nNow + 1].nNum;
}

void TransFlag(SNode* psTree, int nNow)
{
	if (psTree[nNow].nLazyFlag == 0)
		return;

	psTree[2 * nNow].nNum += psTree[nNow].nLazyFlag *
		(psTree[2 * nNow].nRight - psTree[2 * nNow].nLeft + 1);
	psTree[2 * nNow].nLazyFlag += psTree[nNow].nLazyFlag;
	psTree[2 * nNow + 1].nNum += psTree[nNow].nLazyFlag *
		(psTree[2 * nNow + 1].nRight - psTree[2 * nNow + 1].nLeft + 1);
	psTree[2 * nNow + 1].nLazyFlag += psTree[nNow].nLazyFlag;
	psTree[nNow].nLazyFlag = 0;
}

void Change(SNode* psTree, int nNow, int nLeft, 
	int nRight, long long nNum)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
	{
		psTree[nNow].nNum += nNum *
			(psTree[nNow].nRight - psTree[nNow].nLeft + 1);
		psTree[nNow].nLazyFlag += nNum;
		return;
	}
	TransFlag(psTree, nNow);

	int		nMid;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		Change(psTree, 2 * nNow, nLeft,nRight, nNum);
	if (nRight > nMid)
		Change(psTree, 2 * nNow + 1, nLeft, nRight, nNum);

	psTree[nNow].nNum = psTree[2 * nNow].nNum + 
		psTree[2 * nNow + 1].nNum;
}

long long Query(SNode* psTree, int nNow, int nLeft, int nRight)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
		return psTree[nNow].nNum;
	TransFlag(psTree, nNow);

	int			nMid;
	long long	llAns = 0;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		llAns += Query(psTree, 2 * nNow, nLeft, nRight);
	if (nRight > nMid)
		llAns += Query(psTree, 2 * nNow + 1, nLeft, nRight);
	return llAns;
}



int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int				nQ;
	int				nLeft;
	int				nRight;
	int				nNum;
	int*			pnSeq			= NULL;
	SNode*			psTree			= NULL;
	
	scanf("%d%d", &nInputN, &nInputM);

	pnSeq = (int*)malloc((nInputN + 1) * sizeof(int));
	psTree = (SNode*)malloc((4 * nInputN + 4) * sizeof(SNode));

	for (int i = 1; i <= nInputN; i++)
		scanf("%d", pnSeq + i);

	BuildTree(psTree, 1, 1, nInputN, pnSeq);


	while (nInputM--)
	{
		scanf("%d", &nQ);
		if (nQ == 1)
		{
			scanf("%d%d%d", &nLeft, &nRight, &nNum);
			Change(psTree, 1, nLeft, nRight, nNum);
		}
		else
		{
			scanf("%d%d", &nLeft, &nRight);
			cout << Query(psTree, 1, nLeft, nRight) << endl;
		}
	}

Exit0:

	return 0;
}
```

**乘法**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-26 23:00
//	Comment		:	OJ(P3373)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int g_nMode;

typedef struct SNode
{
	int			nLeft;
	int			nRight;
	long long	nLazyAddFlag;
	long long	nLazyMultFlag;
	long long	nNum;
}SNode;


void BuildTree(SNode* psTree, int nNow, int nLeft, 
	int nRight, int* pnSeq)
{
	psTree[nNow].nLazyAddFlag = 0;
	psTree[nNow].nLazyMultFlag = 1;
	psTree[nNow].nLeft = nLeft;
	psTree[nNow].nRight = nRight;
	if (nLeft == nRight)
	{
		psTree[nNow].nNum = pnSeq[nLeft] % g_nMode;
		return ;
	}
	int		nMid;
	nMid = (nLeft + nRight) / 2;

	BuildTree(psTree, 2 * nNow, nLeft,
		nMid, pnSeq);
	BuildTree(psTree, 2 * nNow + 1, nMid + 1,
		nRight, pnSeq);

	psTree[nNow].nNum = (psTree[2 * nNow].nNum + 
		psTree[2 * nNow + 1].nNum) % g_nMode;
}

void TransFlag(SNode* psTree, int nNow)
{
	if (psTree[nNow].nLazyAddFlag == 0 && psTree[nNow].nLazyMultFlag == 1)
		return;
	psTree[2 * nNow].nNum = psTree[2 * nNow].nNum * psTree[nNow].nLazyMultFlag +
		psTree[nNow].nLazyAddFlag * (psTree[2 * nNow].nRight - psTree[2 * nNow].nLeft + 1);
	psTree[2 * nNow].nNum %= g_nMode;

	psTree[2 * nNow + 1].nNum = psTree[2 * nNow + 1].nNum * psTree[nNow].nLazyMultFlag +
		psTree[nNow].nLazyAddFlag * (psTree[2 * nNow + 1].nRight - psTree[2 * nNow + 1].nLeft + 1);
	psTree[2 * nNow + 1].nNum %= g_nMode;

	psTree[2 * nNow].nLazyMultFlag *= psTree[nNow].nLazyMultFlag;
	psTree[2 * nNow].nLazyMultFlag %= g_nMode;

	psTree[2 * nNow + 1].nLazyMultFlag *= psTree[nNow].nLazyMultFlag;
	psTree[2 * nNow + 1].nLazyMultFlag %= g_nMode;

	psTree[2 * nNow].nLazyAddFlag = psTree[2 * nNow].nLazyAddFlag * 
		psTree[nNow].nLazyMultFlag + psTree[nNow].nLazyAddFlag;
	psTree[2 * nNow].nLazyAddFlag %= g_nMode;

	psTree[2 * nNow + 1].nLazyAddFlag = psTree[2 * nNow + 1].nLazyAddFlag *
		psTree[nNow].nLazyMultFlag + psTree[nNow].nLazyAddFlag;
	psTree[2 * nNow + 1].nLazyAddFlag %= g_nMode;
	
	psTree[nNow].nLazyAddFlag = 0;
	psTree[nNow].nLazyMultFlag = 1;

}

void ChangeAdd(SNode* psTree, int nNow, int nLeft, 
	int nRight, long long nNum)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
	{
		psTree[nNow].nNum += nNum *
			(psTree[nNow].nRight - psTree[nNow].nLeft + 1) % g_nMode;
		psTree[nNow].nLazyAddFlag += nNum;
		psTree[nNow].nLazyAddFlag %= g_nMode;
		return;
	}
	TransFlag(psTree, nNow);
	int		nMid;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		ChangeAdd(psTree, 2 * nNow, nLeft,nRight, nNum);
	if (nRight > nMid)
		ChangeAdd(psTree, 2 * nNow + 1, nLeft, nRight, nNum);

	psTree[nNow].nNum = (psTree[2 * nNow].nNum + 
		psTree[2 * nNow + 1].nNum) % g_nMode;
}

void ChangeMult(SNode* psTree, int nNow, int nLeft,
	int nRight, long long nNum)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
	{
		psTree[nNow].nNum = nNum * psTree[nNow].nNum % g_nMode;
		psTree[nNow].nLazyMultFlag *= nNum;
		psTree[nNow].nLazyMultFlag %= g_nMode;
		psTree[nNow].nLazyAddFlag = psTree[nNow].nLazyAddFlag * nNum;
		psTree[nNow].nLazyAddFlag %= g_nMode;
		return;
	}

	TransFlag(psTree, nNow);

	int		nMid;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		ChangeMult(psTree, 2 * nNow, nLeft, nRight, nNum);
	if (nRight > nMid)
		ChangeMult(psTree, 2 * nNow + 1, nLeft, nRight, nNum);

	psTree[nNow].nNum = (psTree[2 * nNow].nNum +
		psTree[2 * nNow + 1].nNum) % g_nMode;
}

long long Query(SNode* psTree, int nNow, int nLeft, int nRight)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
		return psTree[nNow].nNum % g_nMode;

	TransFlag(psTree, nNow);

	int			nMid;
	long long	llAns = 0;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
	{
		llAns += Query(psTree, 2 * nNow, nLeft, nRight);
		llAns %= g_nMode;
	}
		
	if (nRight > nMid)
	{
		llAns += Query(psTree, 2 * nNow + 1, nLeft, nRight);
		llAns %= g_nMode;
	}
		
	return llAns % g_nMode;
}



int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int				nQ;
	int				nLeft;
	int				nRight;
	int				nNum;
	int*			pnSeq			= NULL;
	SNode*			psTree			= NULL;
	scanf("%d%d%d", &nInputN, &nInputM, &g_nMode);

	pnSeq = (int*)malloc((nInputN + 1) * sizeof(int));
	psTree = (SNode*)malloc((4 * nInputN + 4) * sizeof(SNode));

	for (int i = 1; i <= nInputN; i++)
		scanf("%d", pnSeq + i);

	BuildTree(psTree, 1, 1, nInputN, pnSeq);


	while (nInputM--)
	{
		scanf("%d", &nQ);
		if (nQ == 1)
		{
			scanf("%d%d%d", &nLeft, &nRight, &nNum);
			ChangeMult(psTree, 1, nLeft, nRight, nNum);
		}
		else if (nQ == 2)
		{
			scanf("%d%d%d", &nLeft, &nRight, &nNum);
			ChangeAdd(psTree, 1, nLeft, nRight, nNum);
		}
		else
		{
			scanf("%d%d", &nLeft, &nRight);
			cout << Query(psTree, 1, nLeft, nRight) << endl;
		}
	}

Exit0:

	return 0;
}
```

## P1531 I Hate It

**题目描述**

不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩

**输入格式**

第一行，有两个正整数 N 和 M ( 0<N<=200000,0<M<5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取'Q'或'U') ，和两个正整数A，B。当C为'Q'的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为'U'的时候，表示这是一条更新操作，如果当前A学生的成绩低于B，则把ID为A的学生的成绩更改为B，否则不改动。

**输出格式**

对于每一次询问操作，在一行里面输出最高成绩

| input     | output |
| --------- | ------ |
| 5 6       | 5      |
| 1 2 3 4 5 | 6      |
| Q 1 5     | 5      |
| U 3 6     | 9      |
| Q 3 4     |        |
| Q 4 5     |        |
| U 2 9     |        |
| Q 1 5     |        |

**分析**

区间查询

单点更新

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-17 01:03
//	Comment		:	OJ(P1531)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

typedef struct SNode
{
	int			nLeft;
	int			nRight;
	long long	nNum;
}SNode;


void BuildTree(SNode* psTree, int nNow, int nLeft,
	int nRight, int* pnSeq)
{
	psTree[nNow].nLeft = nLeft;
	psTree[nNow].nRight = nRight;
	if (nLeft == nRight)
	{
		psTree[nNow].nNum = pnSeq[nLeft];
		return;
	}
	int		nMid;
	nMid = (nLeft + nRight) / 2;

	BuildTree(psTree, 2 * nNow, nLeft,
		nMid, pnSeq);
	BuildTree(psTree, 2 * nNow + 1, nMid + 1,
		nRight, pnSeq);

	psTree[nNow].nNum = max(psTree[2 * nNow].nNum ,
		psTree[2 * nNow + 1].nNum);
}



void Change(SNode* psTree, int nNow, int nLeft,
	int nRight, long long nNum)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
	{
		psTree[nNow].nNum = nNum;
		return;
	}

	int		nMid;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		Change(psTree, 2 * nNow, nLeft, nRight, nNum);
	if (nRight > nMid)
		Change(psTree, 2 * nNow + 1, nLeft, nRight, nNum);

	psTree[nNow].nNum = max(psTree[2 * nNow].nNum,
		psTree[2 * nNow + 1].nNum);
}

long long Query(SNode* psTree, int nNow, int nLeft, int nRight)
{
	if (nLeft <= psTree[nNow].nLeft && psTree[nNow].nRight <= nRight)
		return psTree[nNow].nNum;

	int			nMid;
	long long	llAns = 0;
	nMid = (psTree[nNow].nLeft + psTree[nNow].nRight) / 2;

	if (nLeft <= nMid)
		llAns = max(Query(psTree, 2 * nNow, nLeft, nRight), llAns);
	if (nRight > nMid)
		llAns = max(Query(psTree, 2 * nNow + 1, nLeft, nRight), llAns);
	return llAns;
}



int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int				nQ;
	int				nLeft;
	int				nRight;
	int				nNum;
	int*			pnSeq = NULL;
	SNode*			psTree = NULL;
	char			szFlag[10];

	scanf("%d%d", &nInputN, &nInputM);

	pnSeq = (int*)malloc((nInputN + 1) * sizeof(int));
	psTree = (SNode*)malloc((4 * nInputN + 4) * sizeof(SNode));

	for (int i = 1; i <= nInputN; i++)
		scanf("%d", pnSeq + i);

	BuildTree(psTree, 1, 1, nInputN, pnSeq);


	while (nInputM--)
	{
		scanf("%s", szFlag);

		if (szFlag[0] == 'Q')
		{
			scanf("%d%d", &nLeft, &nRight);
			printf("%lld\n", Query(psTree, 1, nLeft, nRight));
		}
		else
		{
			scanf("%d%d", &nLeft, &nRight);
			if (pnSeq[nLeft] < nRight)
			{
				Change(psTree, 1, nLeft, nLeft, nRight);
				pnSeq[nLeft] = nRight;
			}
				
		}

	}

Exit0:

	return 0;
}
```



# **图论**

## P1119 灾后重建（Floyd）

**题目描述**

给出B*B*地区的村庄数*N*，村庄编号从0到*N*−1，和所有*M*条公路的长度，公路是双向的。并给出第i个村庄重建完成的时间ti，你可以认为是同时开始重建并在第ti天重建完成，并且在当天即可通车。若ti为0则说明地震未对此地区造成损坏，一开始就可以通车。之后有*Q*个询问(*x*,*y*,*t*)，对于每个询问你要回答在第*t*天，从村庄*x*到村庄y的最短路径长度为多少。如果无法找到从*x*村庄到*y*村庄的路径，经过若干个已重建完成的村庄，或者村庄*x*或村庄*y*在第t天仍未重建完成 ，则需要返回−1。

**输入格式**

第一行包含两个正整数N,M表示了村庄的数目与公路的数量。

第二行包含*N*个非负整数
$$
t 
0
​	
 ,t 
1
​	
 ,…,t 
N−1
​	
 
$$
表示了每个村庄重建完成的时间，数据保证了
$$
t_0 ≤ t_1 ≤ … ≤ t_{N-1}t 
0
​	
 ≤t 
1
​	
 ≤…≤t 
N−1
​	
 
$$
接下来M*M*行，每行33个非负整数i, j, w，*w*为不超过1000010000的正整数，表示了有一条连接村庄*i*与村庄*j*的道路，长度为*w*，保证i≠j，且对于任意一对村庄只会存在一条道路。

接下来一行也就是M+3行包含一个正整数*Q*，表示*Q*个询问。

接下来Q*行，每行3个非负整数x*,*y*,*t*，询问在第t*天，从村庄x*到村庄*y*的最短路径长度为多少，数据保证了*t*是不下降的。

**输出格式**

共*Q*行，对每一个询问(*x*,*y*,*t*)输出对应的答案，即在第*t*天，从村庄*x*到村庄*y*的最短路径长度为多少。如果在第t天无法找到从*x*村庄到y村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未修复完成，则输出−1。

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-26 00:35
//	Comment		:	OJ(P1119)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		1000000000
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;



int main(int argc, char* argv[])
{
	int					nN;
	int					nM;
	int*				pnTime;
	int					nTemp;
	int					nQ;
	int**				ppnMat;
	int					nStrat;
	int					nEnd;
	int					nLong;
	scanf("%d%d", &nN, &nM);

	pnTime = (int*)malloc((nN + 1) * sizeof(int));

	for (int i = 0; i < nN; i++)
		scanf("%d", pnTime + i);

	ppnMat = (int**)malloc((nN + 1) * sizeof(int*));
	for (int i = 0; i <= nN; i++)
	{
		ppnMat[i] = (int*)malloc((nN + 1) * sizeof(int));
		for (int j = 0; j <= nN; j++)
			ppnMat[i][j] = MAXNUM;
		ppnMat[i][i] = 0;
	}

	for (int i = 0; i < nM; i++)
	{
		scanf("%d%d%d", &nStrat, &nEnd, &nLong);
		ppnMat[nStrat][nEnd] = min(ppnMat[nStrat][nEnd], nLong);
		ppnMat[nEnd][nStrat] = min(ppnMat[nEnd][nStrat], nLong);
	}


	scanf("%d", &nQ);

	nTemp = 0;
	for (int i = 0; i < nQ; i++)
	{
		scanf("%d%d%d", &nStrat, &nEnd, &nLong);
		while (pnTime[nTemp] <= nLong && nTemp < nN)
		{
			int k = nTemp;
			for (int i = 0; i < nN; i++)
				for (int j = 0; j < nN; j++)
					ppnMat[i][j] = min(ppnMat[i][j], ppnMat[i][k] + ppnMat[k][j]);
			nTemp++;
		}
		if (pnTime[nStrat] > nLong || pnTime[nEnd] > nLong)
			printf("-1\n");
		else
		{
			if (ppnMat[nStrat][nEnd] == MAXNUM)
				printf("-1\n");
			else
				printf("%d\n", ppnMat[nStrat][nEnd]);
		}

	}

	



Exit0:

	return 0;
}
```

## P1608 路径统计(SPFA变形)

**题目描述**

“RP餐厅”的员工素质就是不一般，在齐刷刷的算出同一个电话号码之后，就准备让HZH,TZY去送快餐了，他们将自己居住的城市画了一张地图，已知在他们的地图上，有N个地方，而且他们目前处在标注为“1”的小镇上，而送餐的地点在标注为“N”的小镇。（有点废话）除此之外还知道这些道路都是单向的，从小镇I到J需要花费D[I,J]的时间，为了更高效快捷的将快餐送到顾客手中，

他们想走一条从小镇1到小镇N花费最少的一条路，但是他们临出发前，撞到因为在路上堵车而生气的FYY，深受启发，不能仅知道一条路线，万一。。。，于是，他们邀请FYY一起来研究起了下一个问题：这个最少花费的路径有多少条？

**输入格式**

输入文件第一行为两个空格隔开的数N，E，表示这张地图里有多少个小镇及有多少边的信息。

下面E行，每行三个数I、J、C，表示从I小镇到J小镇有道路相连且花费为C.（注意，数据提供的边信息可能会重复，不过保证I<>J,1<=I,J<=n）。

**输出格式**

输出文件包含两个数，分别是最少花费和花费最少的路径的总数.

两个不同的最短路方案要求：路径长度相同（均为最短路长度）且至少有一条边不重合。

若城市N无法到达则只输出一个(‘No answer’);

| Input | output |
| ----- | ------ |
| 5 4   | 4 2    |
| 1 5 4 |        |
| 1 2 2 |        |
| 2 5 2 |        |
| 4 1 1 |        |

**分析**

1、 如果搜索到的点到起点的距离等于当前点到起点的距离加上这两点间的那条边的距离，那么我们就将搜索到的点的路径数加上当前点的路径数 。

```c++
if (pnDis[nTemp] + ppnMat[nTemp][i] == pnDis[i])
	pnCount[i] += pnCount[nTemp];
```

2、 如果我们更新了搜索到的点到起点的最短距离，那么我们将到达改点的路径数改为当前点的路径数。

```c++
if (pnDis[nTemp] + ppnMat[nTemp][i] < pnDis[i])
{
    pnDis[i] = pnDis[nTemp] + ppnMat[nTemp][i];
    pnCount[i] = pnCount[nTemp];
}
```

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-25 23:26
//	Comment		:	OJ(P1608)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		1000000000
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;




void SPFA(int nStart, int nEnd, int nN, int* pnCount, int* pnDis,
	int** ppnMat)
{
	queue<int>	qSPFA;
	int			nTemp;
	int*		pnFlag;


	pnFlag = (int*)malloc((nN + 1) * sizeof(int));

	for (int i = 0; i <= nN; i++)
		pnDis[i] = MAXNUM;
	memset(pnFlag, 0, (nN + 1) * sizeof(int));
	memset(pnCount, 0, (nN + 1) * sizeof(int));

	pnCount[nStart] = 1;
	pnDis[nStart] = 0;
	qSPFA.push(nStart);
	pnFlag[nStart] = 1;

	while (!qSPFA.empty())
	{
		nTemp = qSPFA.front();
		qSPFA.pop();
		pnFlag[nTemp] = 0;
		if (nTemp == nEnd)
			continue;
		for (int i = 1; i <= nN; i++)
		{
			if (pnDis[nTemp] + ppnMat[nTemp][i] == pnDis[i])
			{
				pnCount[i] += pnCount[nTemp];
			}

			if (pnDis[nTemp] + ppnMat[nTemp][i] < pnDis[i])
			{
				pnDis[i] = pnDis[nTemp] + ppnMat[nTemp][i];
				pnCount[i] = pnCount[nTemp];
			}
			if (!pnFlag[i] && pnCount[i])
			{
				qSPFA.push(i);
				pnFlag[i] = 1;
			}
		}
		pnCount[nTemp] = 0;
	}

}


int main(int argc, char* argv[])
{
	int					nN;
	int					nM;
	int					nK;
	int					nStart;
	int					nEnd;
	int					nLong;
	int					nTemp;
	long long			llAns = 0;
	int					nNum;
	int*				pnCount;
	int*				pnDis;
	int**				ppnMat;

	scanf("%d%d", &nN, &nM);

	ppnMat = (int**)malloc((nN + 1) * sizeof(int*));
	for (int i = 1; i <= nN; i++)
	{
		ppnMat[i] = (int*)malloc((nN + 1) * sizeof(int));
		for (int j = 1; j <= nN; j++)
			ppnMat[i][j] = MAXNUM;
	}

	pnCount = (int*)malloc((nN + 1) * sizeof(int));
	pnDis = (int*)malloc((nN + 1) * sizeof(int));




	for (int i = 0; i < nM; i++)
	{
		scanf("%d%d%d", &nStart, &nEnd, &nLong);
		ppnMat[nStart][nEnd] = min(ppnMat[nStart][nEnd], nLong);
	}

	SPFA(1, nN, nN, pnCount, pnDis, ppnMat);



	if (pnDis[nN] == MAXNUM)
		printf("No answer");
	else
		printf("%d %d", pnDis[nN], pnCount[nN]);



Exit0:

	return 0;
}
```

## P1038 神经网络(拓扑排序)

**题目背景**

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。

**题目描述**

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![img](https://cdn.luogu.com.cn/upload/pic/13.png) ![img](https://cdn.luogu.com.cn/upload/pic/58251.png)

神经元〔编号为11）

图中，X*1−*X3是信息输入渠道，Y*1−*Y2是信息输出渠道，C1表示神经元目前的状态，Ui是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![img](https://cdn.luogu.com.cn/upload/pic/14.png) ![img](https://cdn.luogu.com.cn/upload/pic/58252.png)

兰兰规定，Ci服从公式：（其中*n*是网络中所有神经元的数目）
$$
C_i=\sum_{(j,i) \in E} W_{ji}C_{j}-U_{i}
$$


公式中的Wji（可能为负值）表示连接*j*号神经元和*i*号神经元的边的权值。当 Ci大于0时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为Ci。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（Ci），要求你的程序运算出最后网络输出层的状态。

**输入格式**

输入文件第一行是两个整数(1≤*n*≤100)和*p*。接下来*n*行，每行2个整数，第i+1行是神经元*i*最初状态和其阈值（Ui），非输入层的神经元开始时状态必然为0。再下面*P*行，每行由22个整数*i*,*j*及11个整数*W**i**j*，表示连接神经元*i*,*j*的边权值为W**i**j。

**输出格式**

输出文件包含若干行，每行有2个整数，分别对应一个神经元的编号，及其最后的状态，2个整数间以空格分隔。仅输出最后状态大于0的输出层神经元状态，并且按照编号由小到大顺序输出。

若输出层的神经元最后状态均为 0，则输出 “NULL”。

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-23 22:08
//	Comment		:	OJ(P1038)
//
///////////////////////////////////////////


//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;



int main(int argc, char* argv[])
{
	queue<int>			qTopu;
	int					nInputN;
	int					nInputP;
	int					nStrat;
	int					nEnd;
	int					nLong;
	int					nTemp;
	vector<pair<int, int> >*		vecMat = NULL;
	int*				pnEnter = NULL;
	int*				pnNow = NULL;
	int*				pnU = NULL;

	scanf("%d%d", &nInputN, &nInputP);

	vecMat = new vector<pair<int, int> >[nInputN + 1];
	pnEnter = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnEnter, 0, (nInputN + 1) * sizeof(int));
	pnNow = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnNow, 0, (nInputN + 1) * sizeof(int));
	pnU = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnU, 0, (nInputN + 1) * sizeof(int));

	for (int i = 1; i <= nInputN; i++)
	{
		scanf("%d%d", pnNow + i, pnU + i);
		pnU[i] = -pnU[i];
	}


	for (int i = 0; i < nInputP; i++)
	{
		scanf("%d%d%d", &nStrat, &nEnd, &nLong);
		vecMat[nStrat].push_back({ nEnd, nLong });
		pnEnter[nEnd]++;
	}

	for (int i = 1; i <= nInputN; i++)
		if (pnEnter[i] == 0 && pnNow[i])
			qTopu.push(i);



	while (!qTopu.empty())
	{
		nTemp = qTopu.front();
		qTopu.pop();
		for (int i = 0; i < vecMat[nTemp].size(); i++)
		{
			pnU[nTemp] = 0;
			pnEnter[vecMat[nTemp][i].first]--;

			pnU[vecMat[nTemp][i].first] += vecMat[nTemp][i].second * pnNow[nTemp];

			if (pnEnter[vecMat[nTemp][i].first] == 0 &&
				pnU[vecMat[nTemp][i].first] > 0)
			{
				qTopu.push(vecMat[nTemp][i].first);
				pnNow[vecMat[nTemp][i].first] = pnU[vecMat[nTemp][i].first];
			}

		}

	}
	int nFlag = 1;
	if (nInputP == 0)
	{
		for (int i = 1; i <= nInputN; i++)
		{
			if (pnNow[i] > 0)
			{
				nFlag = 0;
				printf("%d %d\n", i, pnNow[i]);
			}
		}
	}
	else
		for (int i = 1; i <= nInputN; i++)
		{
			if (pnU[i] > 0)
			{
				nFlag = 0;
				printf("%d %d\n", i, pnU[i]);
			}
		}
	if (nFlag)
		printf("NULL");



Exit0:
	return 0;
}
```

## P1991 无线通讯网（最小生成树）

**题目描述**

国防部计划用无线网络连接若干个边防哨所。2 种不同的通讯技术用来搭建无线网络；

每个边防哨所都要配备无线电收发器；有一些哨所还可以增配卫星电话。

任意两个配备了一条卫星电话线路的哨所（两边都ᤕ有卫星电话）均可以通话，无论他们相距多远。而只通过无线电收发器通话的哨所之间的距离不能超过 D，这是受收发器的功率限制。收发器的功率越高，通话距离 D 会更远，但同时价格也会更贵。

收发器需要统一购买和安装，所以全部哨所只能选择安装一种型号的收发器。换句话说，每一对哨所之间的通话距离都是同一个 D。你的任务是确定收发器必须的最小通话距离 D，使得每一对哨所之间至少有一条通话路径（直接的或者间接的）。

**输入格式**

从 wireless.in 中输入数据第 1 行，2 个整数 S 和 P，S 表示可安装的卫星电话的哨所数，P 表示边防哨所的数量。接下里 P 行，每行两个整数 x，y 描述一个哨所的平面坐标(x, y)，以 km 为单位。

**输出格式**

输出 wireless.out 中

第 1 行，1 个实数 D，表示无线电收发器的最小传输距离，精确到小数点后两位。

| input   | output |
| ------- | ------ |
| 2 4     | 212.13 |
| 0 100   |        |
| 0 300   |        |
| 0 600   |        |
| 150 750 |        |

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-23 00:22
//	Comment		:	OJ(P1991)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <float.h>

using namespace std;
#define	MAXNUM		1000001
#define	EPS         0.0001
#define MODNUM		100000007


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int				nInputP;
	double**		ppnMat = NULL;
	double*			pnDis = 0;
	int*			pnFlag = NULL;
	int*			pnX;
	int*			pnY;
	int				nX;
	int				nY;
	int				nW;
	double			nMin;
	int				nPoint = 1;
	int				nSum = 0;

	scanf("%d%d", &nInputP, &nInputN);

	ppnMat = (double**)malloc((nInputN + 1) * sizeof(double*));
	pnFlag = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnFlag, 0, (nInputN + 1) * sizeof(int));
	pnX = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnX, 0, (nInputN + 1) * sizeof(int));
	pnY = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnY, 0, (nInputN + 1) * sizeof(int));
	pnDis = (double*)malloc((nInputN + 1) * sizeof(double));

	for (int i = 1; i <= nInputN; i++)
	{
		ppnMat[i] = (double*)malloc((nInputN + 1) * sizeof(double));
		memset(ppnMat[i], 0, (nInputN + 1) * sizeof(double));
	}
	pnDis[0] = 2000000000;
	for (int i = 1; i <= nInputN; i++)
	{
		scanf("%d%d", pnX + i, pnY + i);
		pnDis[i] = 2000000000;
	}

	for (int i = 1; i <= nInputN; i++)
	{
		for (int j = 1; j <= nInputN; j++)
		{
			ppnMat[i][j] = sqrt((pnX[i] - pnX[j]) * 1.0 * (pnX[i] - pnX[j]) +
				(pnY[i] - pnY[j]) * 1.0 * (pnY[i] - pnY[j]));
		}
	}


	pnDis[1] = 0;
	for (int i = 1; i <= nInputN; i++)
	{
		nMin = pnDis[0];
		for (int j = 1; j <= nInputN; j++)
		{
			if (pnDis[j] < nMin && pnFlag[j] == false)
			{
				nMin = pnDis[j];
				nPoint = j;
			}
		}

		pnFlag[nPoint] = true;

		for (int j = 1; j <= nInputN; j++)
		{
			if (ppnMat[nPoint][j] != 0)
			{
				if (pnDis[j] > ppnMat[nPoint][j] && pnFlag[j] == false)
					pnDis[j] = ppnMat[nPoint][j];
			}
		}
	}

	sort(pnDis + 1, pnDis + 1 + nInputN);
	printf("%.2f", pnDis[nInputN - nInputP + 1]);

Exit0:

	return 0;
}
```

## P1661扩散（并查集 + 二分答案）

**题目描述**

一个点每过一个单位时间就会向四个方向扩散一个距离，如图。

![img](https://cdn.luogu.com.cn/upload/pic/455.png)

两个点a、b连通，记作e(a,b),当且仅当a、b的扩散区域有公共部分。连通块的定义是块内的任意两个点u、v都必定存在路径e(u,a0),e(a0,a1),…,e(ak,v)。给定平面上的n给点，问最早什么时刻它们形成一个连通块。

**输入格式**

第一行一个数n，以下n行，每行一个点坐标。

【数据规模】

对于20%的数据，满足1≤N≤5; 1≤X[i],Y[i]≤50;

对于100%的数据，满足1≤N≤50; 1≤X[i],Y[i]≤10^9。

**输出格式**

一个数，表示最早的时刻所有点形成连通块。

**输入输出样例**

| input | output |
| ----- | ------ |
| 2     | 5      |
| 0 0   |        |
| 5 5   |        |

**分析**

二分时间

检查时间能不让图中的点能不能让所以点连成一块。

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-23 15:57
//	Comment		:	OJ(P1661)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <float.h>

using namespace std;
#define	MAXNUM		10000017
#define	EPS         0.0001
#define MODNUM		100000007


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int Fin(int* pnSet, int nNum)
{
	if (pnSet[nNum] == nNum)
		return pnSet[nNum];
	else
		return pnSet[nNum] =
		Fin(pnSet, pnSet[nNum]);
}

int main(int argc, char* argv[])
{
	int				nInputN;
	int*			pnX;
	int*			pnY;
	int*			pnSet;
	int				nLeft;
	int				nRight;
	int				nMid;
	int				nDis;
	int				nCount;
	scanf("%d", &nInputN);
	pnX = (int*)malloc((nInputN + 1) * sizeof(int));
	pnY = (int*)malloc((nInputN + 1) * sizeof(int));
	pnSet = (int*)malloc((nInputN + 1) * sizeof(int));
	for (int i = 1; i <= nInputN; i++)
		pnSet[i] = i;

	for (int i = 1; i <= nInputN; i++)
		scanf("%d%d", pnX + i, pnY + i);

	nLeft = 0;
	nRight = 1000000000;
	while (nLeft <= nRight)
	{
		nMid = (nLeft + nRight) / 2;
		for (int i = 1; i <= nInputN; i++)
			pnSet[i] = i;
		for (int i = 1; i <= nInputN; i++)
			for (int j = i + 1; j <= nInputN; j++)
			{
				nDis = abs(pnX[i] - pnX[j]) + abs(pnY[i] - pnY[j]);
				if (nDis <= nMid * 2)
				{
					if (Fin(pnSet, i) != Fin(pnSet, j))
						pnSet[Fin(pnSet, i)] = Fin(pnSet, j);
				}
			}
		nCount = 0;
		for (int i = 1; i <= nInputN; i++)
		{
			if (pnSet[i] == i)
				nCount++;
		}

		if (nCount == 1)
			nRight = nMid - 1;
		else
			nLeft = nMid + 1;
	}

	printf("%d", nRight + 1);

Exit0:

	return 0;
}
```

## P1550 [USACO08OCT]打井Watering Hole(Djisteka)

**题目描述**

农民John 决定将水引入到他的n(1<=n<=300)个牧场。他准备通过挖若

干井，并在各块田中修筑水道来连通各块田地以供水。在第i 号田中挖一口井需要花费W_i(1<=W_i<=100,000)元。连接i 号田与j 号田需要P_ij (1 <= P_ij <= 100,000 , P_ji=P_ij)元。

请求出农民John 需要为使所有农场都与有水的农场相连或拥有水井所需要的钱数。

**输入格式**

第1 行为一个整数n。

第2 到n+1 行每行一个整数，从上到下分别为W_1 到W_n。

第n+2 到2n+1 行为一个矩阵，表示需要的经费（P_ij）。

**输出格式**

只有一行，为一个整数，表示所需要的钱数。

**输入输出样例**

| input   | output |
| ------- | ------ |
| 4       | 9      |
| 5       |        |
| 4       |        |
| 4       |        |
| 3       |        |
| 0 2 2 2 |        |
| 2 0 3 3 |        |
| 2 3 0 4 |        |
| 2 3 4 0 |        |

**分析**

把地底下的水当作另外一个点

共n+1个点做Djisteka

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-23 20:05
//	Comment		:	OJ(P1550)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <float.h>

using namespace std;
#define	MAXNUM		1000001
#define	EPS         0.0001
#define MODNUM		100000007


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	int					nInputN;
	int*				pnW;
	int**				ppnMat					= NULL;
	int*				pnDis = NULL;
	int*				pnFlag = NULL;
	int					nMin;
	int					nPoint;
	int					nSum = 0;

	scanf("%d", &nInputN);

	ppnMat = (int**)malloc((nInputN + 1) * sizeof(int*));
	for (int i = 0; i <= nInputN; i++)
	{
		ppnMat[i] = (int*)malloc((nInputN + 1) * sizeof(int));
		memset(ppnMat[i], 0, (nInputN + 1) * sizeof(int));
	}

	pnDis = (int*)malloc((nInputN + 1) * sizeof(int));
	for (int i = 0; i <= nInputN; i++)
		pnDis[i] = 2000000000;

	pnFlag = (int*)malloc((nInputN + 1) * sizeof(int));
	memset(pnFlag, 0, (nInputN + 1) * sizeof(int));

	for (int i = 1; i <= nInputN; i++)
	{
		scanf("%d", &ppnMat[0][i]);
		ppnMat[i][0] = ppnMat[0][i];
	}

	for (int i = 1; i <= nInputN; i++)
		for (int j = 1; j <= nInputN; j++)
			scanf("%d", &ppnMat[i][j]);

	pnDis[0] = 0;
	for (int i = 0; i <= nInputN; i++)
	{

		nMin = 2000000000;
		for (int j = 0; j <= nInputN; j++)
		{
			if (pnDis[j] < nMin && pnFlag[j] == false)
			{
				nMin = pnDis[j];
				nPoint = j;
			}
		}

		pnFlag[nPoint] = true;

		for (int j = 0; j <= nInputN; j++)
		{
			if (ppnMat[nPoint][j] != 0)
			{
				if (pnDis[j] > ppnMat[nPoint][j] && pnFlag[j] == false)
					pnDis[j] = ppnMat[nPoint][j];
			}
		}
	}

	for (int i = 0; i <= nInputN; i++)
		nSum += pnDis[i];

	printf("%d", nSum);

		
Exit0:

	return 0;
}
```

## P1656 炸铁路（并查集）

**题目描述**

因为某国被某红色政权残酷的高压暴力统治。美国派出将军uim，对该国进行战略性措施，以解救涂炭的生灵。

该国有n个城市，这些城市以铁路相连。任意两个城市都可以通过铁路直接或者间接到达。

uim发现有些铁路被毁坏之后，某两个城市无法互相通过铁路到达。这样的铁路就被称为key road。

uim为了尽快使该国的物流系统瘫痪，希望炸毁铁路，以达到存在某两个城市无法互相通过铁路到达的效果。

然而，只有一发炮弹（美国国会不给钱了）。所以，他能轰炸哪一条铁路呢？

**输入格式**

第一行n，m(1<=n<=150, 1<=m<=5000)，分别表示有n个城市，总共m条铁路。

以下m行,每行两个整数a, b，表示城市a和城市b之间有铁路直接连接。

**输出格式**

输出有若干行。

每行包含两个数字a,b(a<b)，表示<a,b>是key road。

请注意：输出时，所有的数对<a,b>必须按照a从小到大排序输出；如果a相同，则根据b从小到大排序。

| input | output |
| ----- | ------ |
| 6 6   | 1 2    |
| 1 2   | 5 6    |
| 2 3   |        |
| 2 4   |        |
| 3 5   |        |
| 4 5   |        |

5 6

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-15 18:44
//	Comment		:	OJ(P1656)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <list>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int Fin(int* pnSet, int nNum)
{
	if (pnSet[nNum] == nNum)
		return pnSet[nNum];
	else
		return pnSet[nNum] =
		Fin(pnSet, pnSet[nNum]);
}

int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int*			pnSet				= NULL;
	int				nCount;
	pair<int, int>*	prTemp				= NULL;

	scanf("%d%d", &nInputN, &nInputM);

	pnSet = (int*)malloc((nInputN + 1) * sizeof(int));
	prTemp = new pair<int, int>[nInputM];

	

	for (int i = 0; i < nInputM; i++)
	{
		scanf("%d%d", &prTemp[i].first, &prTemp[i].second);
		if (prTemp[i].first > prTemp[i].second)
			swap(prTemp[i].first, prTemp[i].second);
	}
	sort(prTemp, prTemp + nInputM);
	for (int i = 0; i < nInputM; i++)
	{
		nCount = 0;
		for (int j = 1; j <= nInputN; j++)
			pnSet[j] = j;
		for (int j = 0; j < nInputM; j++)
		{
			if (i == j)
				continue;
			pnSet[Fin(pnSet, prTemp[j].first)] = 
				Fin(pnSet, prTemp[j].second);
		}
		for (int j = 1; j <= nInputN; j++)
			if (pnSet[j] == j)
				nCount++;
		if (nCount >= 2)
			printf("%d %d\n", prTemp[i].first, prTemp[i].second);
	}



Exit0:

	return 0;
}
```

# **搜索**

## P1443 马的遍历（BFS）

**题目描述**

有一个n*m的棋盘(1<n,m<=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步

**输入格式**

一行四个数据，棋盘的大小和马的坐标

**输出格式**

一个n*m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1）

**输入输出样例**

| input   | output |
| ------- | ------ |
| 3 3 1 1 | 0 3 2  |
|         | 3 -1 1 |
|         | 2 1 4  |

**分析**

用BFS模拟马走， 把对应位置上的答案填上。

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-20 15:54
//	Comment		:	OJ(P1443)
//
///////////////////////////////////////////


//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

int**				ppnGuide			= NULL;

void BFS(int nStartX, int nStartY, int** ppnCount, int nN, int nM)
{
	queue<pair<int, int> >	qBFS;
	pair<int, int>			prTemp;
	pair<int, int>			prNew;
	int						nQSize;
	int						nCount				= 0;
	int						nNewX;
	int						nNewY;
	int**					ppnFlag				= NULL;

	ppnFlag = (int**)malloc((nN + 1) * sizeof(int*));

	for (int i = 1; i <= nN; i++)
	{
		ppnFlag[i] = (int*)malloc((nM + 1) * sizeof(int));
		memset(ppnFlag[i], 0, (nM + 1) * sizeof(int));
	}

	prTemp.first = nStartX;
	prTemp.second = nStartY;
	ppnFlag[nStartX][nStartY] = 1;
	qBFS.push(prTemp);

	while (!qBFS.empty())
	{
		nQSize = qBFS.size();
		while (nQSize--)
		{
			prTemp = qBFS.front();
			qBFS.pop();
			for (int i = 4; i < 12; i++)
			{
				nNewX = prTemp.first + ppnGuide[i][0];
				nNewY = prTemp.second + ppnGuide[i][1];

				if (nNewX < 1 || nNewX > nN)
					continue;

				if (nNewY < 1 || nNewY > nM)
					continue;

				prNew.first = nNewX;
				prNew.second = nNewY;

				if (!ppnFlag[nNewX][nNewY])
				{
					ppnFlag[nNewX][nNewY] = 1;
					ppnCount[nNewX][nNewY] = nCount + 1;
					qBFS.push(prNew);
				}
			}

		}///while (nQSize--)
		nCount++;
	}///while (true)


}


int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int				nInputX;
	int				nInputY;
	int				nTemp					= -1;
	int**			ppnCount				= NULL;

	ppnGuide = (int**)malloc(12 * sizeof(int*));

	for (int i = 0; i < 12; i++)
		ppnGuide[i] = (int*)malloc(2 * sizeof(int));

	ppnGuide[0][0] = 2; ppnGuide[0][1] = 2;
	ppnGuide[1][0] = 2; ppnGuide[1][1] = -2;
	ppnGuide[2][0] = -2; ppnGuide[2][1] = 2;
	ppnGuide[3][0] = -2; ppnGuide[3][1] = -2;
	ppnGuide[4][0] = -1; ppnGuide[4][1] = -2;
	ppnGuide[5][0] = -1; ppnGuide[5][1] = 2;
	ppnGuide[6][0] = 1; ppnGuide[6][1] = -2;
	ppnGuide[7][0] = 1; ppnGuide[7][1] = 2;
	ppnGuide[8][0] = -2; ppnGuide[8][1] = 1;
	ppnGuide[9][0] = -2; ppnGuide[9][1] = -1;
	ppnGuide[10][0] = 2; ppnGuide[10][1] = 1;
	ppnGuide[11][0] = 2; ppnGuide[11][1] = -1;

	scanf("%d%d%d%d", &nInputN, &nInputM, &nInputX, &nInputY);


	ppnCount = (int**)malloc((nInputN + 1) * sizeof(int*));

	for (int i = 1; i <= nInputN; i++)
	{
		ppnCount[i] = (int*)malloc((nInputM + 1) * sizeof(int));
		memset(ppnCount[i], 0, (nInputM + 1) * sizeof(int));
	}

	BFS(nInputX, nInputY, ppnCount, nInputN, nInputM);

	for (int i = 1; i <= nInputN; i++)
	{
		for (int j = 1; j <= nInputM; j++)
		{
			if (ppnCount[i][j] != 0)
				printf("%-5d", ppnCount[i][j]);
			else
			{
				if (i == nInputX && j == nInputY)
					nTemp = 0;
				else
					nTemp = -1;
				printf("%-5d", nTemp);
			}
		}
			
		printf("\n");
	}
		
Exit0:
	return 0;
}
```

## P1331 海战（BFS）

**题目描述**

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了F-2003飞机。此外，巡洋船只和舰队将被派去保护海岸线。不幸的是因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们考虑培养一些新的海军指挥官，他们选择了“海战”游戏来帮助学习。

在这个著名的游戏中，在一个方形的盘上放置了固定数量和形状的船只，每只船却不能碰到其它的船。在这个题中，我们仅考虑船是方形的，所有的船只都是由图形组成的方形。编写程序求出该棋盘上放置的船只的总数。

**输入格式**

输入文件头一行由用空格隔开的两个整数R和C组成，1<=R,C<=1000，这两个数分别表示游戏棋盘的行数和列数。接下来的R行每行包含C个字符，每个字符可以为“#”，也可为“.”，“#”表示船只的一部分，“.”表示水。

**输出格式**

为每一个段落输出一行解。如果船的位置放得正确（即棋盘上只存在相互之间不能接触的方形，如果两个“#”号上下相邻或左右相邻却分属两艘不同的船只，则称这两艘船相互接触了）。就输出一段话“There are S ships.”,S表示船只的数量。否则输出“Bad placement.”。

| input    | output             |
| -------- | ------------------ |
| .....#.# | There are 5 ships. |
| ##.....# |                    |
| ##.....# |                    |
| .......# |                    |
| #......# |                    |
| #..#...# |                    |

**分析**

难点在于船的相邻

以下代码可以判断是否相邻

```c++
for (int i = 1; i < nInputN; i++)
	for (int j = 1; j < nInputM; j++)
	{
		nCount = 0;
		if (ppnMat[i][j])
			nCount++;
		if (ppnMat[i + 1][j])
			nCount++;
		if (ppnMat[i][j + 1])
			nCount++;
		if (ppnMat[i + 1][j + 1])
			nCount++;
		if (nCount == 3)
		{
			printf("Bad placement.");
			return 0;
		}
	}
```

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-7 23:17
//	Comment		:	OJ(P1331)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

void DFS(int** ppnMat, int** ppnGuide, int nN, int nM, int nNowX, int nNowY)
{
	ppnMat[nNowX][nNowY] = 0;
	for (int i = 0; i < 4; i++)
	{
		int nNewX = nNowX + ppnGuide[i][0];
		int nNewY = nNowY + ppnGuide[i][1];
		if (nNewX < 1 || nNewX > nN)
			continue;
		if (nNewY < 1 || nNewY > nM)
			continue;
		if (ppnMat[nNewX][nNewY])
			DFS(ppnMat, ppnGuide, nN, nM, nNewX, nNewY);
	}
}


int main(int argc, char* argv[])
{
	int								nInputN;
	int								nInputM;
	int**							ppnMat				= NULL;
	string							szTemp;
	int								nCount;
	int**							ppnGuide = NULL;
	int								nAns				= 0;
	ppnGuide = (int**)malloc(4 * sizeof(int*));
	for (int i = 0; i < 4; i++)
		ppnGuide[i] = (int*)malloc(2 * sizeof(int));

	ppnGuide[0][0] = 0; ppnGuide[0][1] = -1;
	ppnGuide[1][0] = -1; ppnGuide[1][1] = 0;
	ppnGuide[2][0] = 0; ppnGuide[2][1] = 1;
	ppnGuide[3][0] = 1; ppnGuide[3][1] = 0;

	scanf("%d%d", &nInputN, &nInputM);

	ppnMat = (int**)malloc((nInputN + 1) * sizeof(int*));

	for (int i = 1; i <= nInputN; i++)
		ppnMat[i] = (int*)malloc((nInputM + 1) * sizeof(int));

	for (int i = 1; i <= nInputN; i++)
	{
		cin >> szTemp;
		for (int j = 0; j < nInputM; j++)
		{
			if (szTemp[j] == '.')
				ppnMat[i][j + 1] = 0;
			else
				ppnMat[i][j + 1] = 1;
		}
	}

	for (int i = 1; i < nInputN; i++)
		for (int j = 1; j < nInputM; j++)
		{
			nCount = 0;
			if (ppnMat[i][j])
				nCount++;
			if (ppnMat[i + 1][j])
				nCount++;
			if (ppnMat[i][j + 1])
				nCount++;
			if (ppnMat[i + 1][j + 1])
				nCount++;
			if (nCount == 3)
			{
				printf("Bad placement.");
				return 0;
			}
		}


	for (int i = 1; i <= nInputN; i++)
		for (int j = 1; j <= nInputM; j++)
		{
			if (ppnMat[i][j])
			{
				DFS(ppnMat, ppnGuide, nInputN, nInputM, i, j);
				nAns++;
			}
		}

	printf("There are %d ships.", nAns);

Exit0:

	return 0;
}
```

## P1434 [SHOI2002]滑雪（记忆化搜索）

**题目描述**

Michael喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：

```
1   2   3   4   5
16  17  18  19   6
15  24  25  20   7
14  23  22  21   8
13  12  11  10   9
```

一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可行的滑坡为24－17－16－1（从24开始，在1结束）。当然25－24－23－...－3－2－1更长。事实上，这是最长的一条。

**输入格式**

输入的第一行为表示区域的二维数组的行数R和列数C（1≤R，C≤100）。下面是R行，每行有C个数，代表高度(两个数字之间用1个空格间隔)。

**输出格式**

输出区域中最长滑坡的长度。

**输入输出样例**

| input         | output |
| ------------- | ------ |
| 5 5           | 25     |
| 1 2 3 4 5     |        |
| 16 17 18 19 6 |        |
| 15 24 25 20 7 |        |
| 14 23 22 21 8 |        |
| 13 12 11 10 9 |        |

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-11-10 23:31
//	Comment		:	OJ(P1434)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;
int				nMax	= 0;

int DFS(int** ppnMat, int** ppnAns, int** ppnGuide,
	int nN, int nM, int nNX, int nNY)
{
	if (ppnAns[nNX][nNY])
		return ppnAns[nNX][nNY];
	
	int nAns = 1;
	for (int i = 0; i < 4; i++)
	{
		int nNewX = nNX + ppnGuide[i][0];
		int nNewY = nNY + ppnGuide[i][1];
		if (nNewX < 1 || nNewX > nN)
			continue;
		if (nNewY < 1 || nNewY > nM)
			continue;
		if (ppnMat[nNewX][nNewY] < ppnMat[nNX][nNY])
			nAns = max(nAns, DFS(ppnMat, ppnAns, ppnGuide,
				nN, nM, nNewX, nNewY) + 1);
	}
	ppnAns[nNX][nNY] = nAns;
	nMax = max(nAns, nMax);
	return nAns;
}


int main(int argc, char* argv[])
{
	int				nInputN;
	int				nInputM;
	int**			ppnMat				= NULL;
	int**			ppnAns				= NULL;
	int**			ppnGuide			= NULL;

	ppnGuide = (int**)malloc(3 * sizeof(int*));
	for (int i = 0; i < 4; i++)
		ppnGuide[i] = (int*)malloc(2 * sizeof(int));

	ppnGuide[0][0] = 0; ppnGuide[0][1] = -1;
	ppnGuide[1][0] = -1; ppnGuide[1][1] = 0;
	ppnGuide[2][0] = 0; ppnGuide[2][1] = 1;
	ppnGuide[3][0] = 1; ppnGuide[3][1] = 0;
	scanf("%d%d", &nInputN, &nInputM);

	ppnMat = (int**)malloc((nInputN + 1) * sizeof(int*));
	ppnAns = (int**)malloc((nInputN + 1) * sizeof(int*));
	for (int i = 1; i <= nInputN; i++)
	{
		ppnMat[i] = (int*)malloc((nInputM + 1) * sizeof(int));
		ppnAns[i] = (int*)malloc((nInputM + 1) * sizeof(int));
		memset(ppnAns[i], 0, (nInputM + 1) * sizeof(int));
	}

	for (int i = 1; i <= nInputN; i++)
		for (int j = 1; j <= nInputM; j++)
			scanf("%d", &ppnMat[i][j]);

	for (int i = 1; i <= nInputN; i++)
		for (int j = 1; j <= nInputM; j++)
		{
			DFS(ppnMat, ppnAns, ppnGuide, nInputN, nInputM, i, j);
		}

	printf("%d", nMax);
Exit0:

	return 0;
}
```

## P1219 八皇后（DFS）

**题目描述**

检查一个如下的6 x 6的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。

![img](https://cdn.luogu.com.cn/upload/pic/60.png)

上面的布局可以用序列2 4 6 1 3 5来描述，第i个数字表示在第i行的相应位置有一个棋子，如下：

行号 1 2 3 4 5 6

列号 2 4 6 1 3 5

这只是跳棋放置的一个解。请编一个程序找出所有跳棋放置的解。并把它们以上面的序列方法输出。解按字典顺序排列。请输出前3个解。最后一行是解的总个数。

//以下的话来自usaco官方，不代表洛谷观点

特别注意: 对于更大的N(棋盘大小N x N)你的程序应当改进得更有效。不要事先计算出所有解然后只输出(或是找到一个关于它的公式），这是作弊。如果你坚持作弊，那么你登陆USACO Training的帐号删除并且不能参加USACO的任何竞赛。我警告过你了！

**输入格式**

一个数字N (6 <= N <= 13) 表示棋盘是N x N大小的。

**输出格式**

前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

**输入输出样例**

| input | output      |
| ----- | ----------- |
| 6     | 2 4 6 1 3 5 |
|       | 3 6 2 5 1 4 |
|       | 4 1 5 2 6 3 |
|       | 4           |

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-19 21:33
//	Comment		:	OJ(P1219)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <float.h>

using namespace std;
#define	MAXNUM		1000001
#define	EPS         0.0001
#define MODNUM		100000007


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int			nFlag1[100];
int			nFlag2[100];

int			nFlag3[100];


void DFS(int** ppnFlag, int* pnReCord, int nPre,
	int nCount, int nN, int& nAns)
{
	if (nCount >= nN + 1)
	{
		nAns++;
		if (nAns <= 3)
		{
			for (int i = 1; i < nCount; i++)
				printf("%d ", pnReCord[i]);
			printf("\n");
		}
		return;
	}

	for (int i = 1; i <= nN; i++)
	{
		if (!nFlag3[i] && !nFlag1[nCount + i] && !nFlag2[nCount - i + nN])
		{
			nFlag3[i] = 1;
			ppnFlag[nCount][i] = 1;
			nFlag2[nCount - i + nN] = 1;
			nFlag1[nCount + i] = 1;
			pnReCord[nCount] = i;
			DFS(ppnFlag, pnReCord, i, nCount + 1, nN, nAns);
			ppnFlag[nCount][i] = 0;
			nFlag2[nCount - i + nN] = 0;
			nFlag1[nCount + i] = 0;
			nFlag3[i] = 0;
		}
	}
}

int main(int argc, char* argv[])
{
	int					nInputN;
	int**				ppnFlag				= NULL;
	int*				pnReCord			= NULL;
	int					nAns				= 0;
	scanf("%d", &nInputN);

	ppnFlag = (int**)malloc((nInputN + 1) * sizeof(int*));
	pnReCord = (int*)malloc((nInputN + 2) * sizeof(int));
	for (int i = 1; i <= nInputN; i++)
	{
		ppnFlag[i] = (int*)malloc((nInputN + 1) * sizeof(int));
		memset(ppnFlag[i], 0, (nInputN + 1) * sizeof(int));
	}

	DFS(ppnFlag, pnReCord, 0, 1, nInputN, nAns);

	printf("%d", nAns);

Exit0:

	return 0;
}
```

## P1025 数的划分（DFS + 剪枝）

**题目描述**

将整数n*n*分成k*k*份，且每份不能为空，任意两个方案不相同(不考虑顺序)。

例如：n*=7，k*=3，下面三种分法被认为是相同的。
$$
1,1,5;
1,5,1;
5,1,1.
$$
问有多少种不同的分法。

**输入格式**
$$
n,k (6<n \le 2006<n≤200，2 \le k \le 62≤k≤6)
$$
**输出格式**

1个整数，即不同的分法。

**输入输出样例**

| input | output |
| ----- | ------ |
| 7 3   | 4      |

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-18 00:26
//	Comment		:	OJ(P1025)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <float.h>

using namespace std;
#define	MAXNUM		1000001
#define	EPS         0.0001
#define MODNUM		100000007


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

void DFS(int nN, int nK, int nCount, int nPre, int nSum, int& nAns)
{
    //cout << "nC " << nCount << " nPre " << nPre << " nSum " << nSum << endl;
    if (nSum > nN)
        return;
    if (nCount == nK - 1)
    {
        if (nN - nSum >= nPre)
            nAns++;
        return;
    }
    for (int i = nPre; i <= nN - nSum; i++)
        DFS(nN, nK, nCount + 1, i, nSum + i, nAns);
}


int main(int argc, char* argv[])
{
    int					nInputN;
    int					nInputK;
    int                 nCount              = 0;
    scanf("%d%d", &nInputN, &nInputK);
    DFS(nInputN, nInputK, 0, 1, 0, nCount);
    printf("%d", nCount);

Exit0:

    return 0;
}
```

# **大模拟**

## P2790 ccj与zrz之积木问题(STL vector)

**题目描述**

从左到右有n个木块，编号从0到n-1，要求模拟以下4种操作（下面的a和B都是木块编号，归为表示比如1号木块归到1号位去）。

move a onto b 把a和b上方的木块全部归位，然后把a摞在b上面。

move a over b 把a上方的全部归位，然后把a放在b所在木块堆的顶部。

pile a onto b 把b上方的木块全部归位，然后把a及上面的木块整体摞在b上面

pile a over b 把a及上面的木块整体摞在b所在木块堆的顶部。

遇到quit停止。a和b在同一堆的指令时非法指令，应当忽略。

最后输出每个位置的木块列表，按照从底部到顶部的顺序排列。

**输入格式**

第一行:n。

接下来若干行：每行一个指令（语法不会错），遇到quit停止。

**输出格式**

n行，第i行输出一个i和冒号，然后一个空格，输出，它位置上的所有积木。

**输入输出样例**

| input         | output     |
| ------------- | ---------- |
| 10            | 0: 0       |
| move 9 onto 1 | 1: 1 9 2 4 |
| move 8 over 1 | 2:         |
| move 7 over 1 | 3: 3       |
| move 6 over 1 | 4:         |
| pile 8 over 6 | 5: 5 8 7 6 |
| pile 8 over 5 | 6:         |
| move 2 over 1 | 7:         |
| move 4 over 9 | 8:         |
| quit          | 9:         |

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-7 21:38
//	Comment		:	OJ(P2790)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		2e31


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;

void Find(vector<int>* pvecNum, int nN, int nNum, int& nP, int& nH)
{
	for (nP = 0; nP < nN; nP++)
		for (nH = 0; nH < pvecNum[nP].size(); nH++)
			if (pvecNum[nP][nH] == nNum)
				return;
}

void Clear(vector<int>* pvecNum,int nP, int nH)
{
	int nTemp;
	for (int i = nH + 1; i < pvecNum[nP].size(); i++)
	{
		nTemp = pvecNum[nP][i];
		pvecNum[nTemp].push_back(nTemp);
	}
	pvecNum[nP].resize(nH + 1);
}

void Pile(vector<int>* pvecNum,int nP, int nH, int nP2)
{
	int n = pvecNum[nP].size();
	for (int i = nH; i < pvecNum[nP].size(); i++)
		pvecNum[nP2].push_back(pvecNum[nP][i]);
	pvecNum[nP].resize(nH);
}



int main(int argc, char* argv[])
{
	int					nN;
	vector<int>*		pvecNum;
	string				szInput;
	string				sz2;
	int					nA;
	int					nB;
	scanf("%d", &nN);
	pvecNum = new vector<int>[nN];

	for (int i = 0; i < nN; i++)
		pvecNum[i].push_back(i);


	while (true)
	{
		cin >> szInput;
		if (szInput == "quit")
			break;
		cin >> nA >> sz2 >> nB;
		int nPa = 0;
		int nPb = 0;
		int nHa = 0;
		int nHb = 0;

		if (nA == nB)
			continue;

		Find(pvecNum, nN, nA, nPa, nHa);
		Find(pvecNum, nN, nB, nPb, nHb);
		if (nPa == nPb)
			continue;
		if (sz2 == "onto")
			Clear(pvecNum, nPb, nHb);
		if (szInput == "move")
			Clear(pvecNum, nPa, nHa);

		Pile(pvecNum, nPa, nHa, nPb);

	}

	for (int i = 0; i < nN; i++)
	{
		printf("%d:", i);

		for (int j = 0; j < pvecNum[i].size(); j++)
			printf(" %d", pvecNum[i][j]);
		printf("\n");
	}

Exit0:

	return 0;
}
```

# **高精**

## P1601 A+B Problem（高精）

**题目描述**

高精度加法,相当于a+b problem，**不用考虑负数**.

**输入格式**

分两行输入。
$$
a,b<=10^{500}
$$
**输出格式**

输出只有一行，代表a*+*b*的值

**输入输出样例**

| input | output |
| ----- | ------ |
| 1     | 2      |
| 1     |        |

**Code**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-6 23:09
//	Comment		:	OJ(P1255)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>

using namespace std;
#define	MAXNUM		150
#define	EPS         0.0001
#define MODNUM		1000000007ll


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


string Add(string szA, string& szB)
{
	if (szA.length() < szB.length())
		swap(szA, szB);
	int			nALen			= szA.length();
	int			nBLen			= szB.length();
	int			nPre			= 0;
	int			nA;
	int			nB;
	while (nALen > 0 || nBLen > 0)
	{
		if (nALen > 0)
		{
			nALen--;
			nA = szA[nALen] - '0';
		}
		else
			nA = 0;
		if (nBLen > 0)
		{
			nBLen--;
			nB = szB[nBLen] - '0';
		}
		else
			nB = 0;
		szA[nALen] = (nA + nB + nPre) % 10 + '0';
		nPre = (nA + nB + nPre) / 10;
	}
	if (nPre > 0)
		szA = "1" + szA;
	return szA;

}
int main(int argc, char* argv[])
{
    string      szInputA;
    string      szInputB;
    
    cin >> szInputA >> szInputB;
    cout << Add(szInputA, szInputB) << endl;


Exit0:

	return 0;
}
```

## P1303 A*B Problem

**输入格式**

两行，两个数。

**输出格式**

积

**输入输出样例**

| input | output |
| ----- | ------ |
| 1     | 2      |
| 2     |        |

**Code**

```
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-10-3 18:21
//	Comment		:	OJ(P1303)
//
///////////////////////////////////////////

//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		100000000
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;


int main(int argc, char* argv[])
{
	string			szNum1;
	string			szNum2;
	int*			pnNum1					= NULL;
	int*			pnNum2					= NULL;
	int*			pnOutput				= NULL;
	
	int				nOutputLen				= 0;
	int				nPre					= 0;
	cin >> szNum1 >> szNum2;

	pnNum1 = (int*)malloc((szNum1.length() + 1) * sizeof(int));
	pnNum2 = (int*)malloc((szNum2.length() + 1) * sizeof(int));
	for (int i = 0; i < szNum1.length(); i++)
		pnNum1[szNum1.length() - i] = szNum1[i] - '0';
	for (int i = 0; i < szNum2.length(); i++)
		pnNum2[szNum2.length() - i] = szNum2[i] - '0';

	pnOutput = (int*)malloc((szNum1.length() + szNum2.length() + 1) * 
		sizeof(int));
	memset(pnOutput, 0, (szNum1.length() + szNum2.length() + 1) *
		sizeof(int));
	
	for (int i = 1; i < szNum1.length() + 1; i++)
	{
		for (int j = 1; j < szNum2.length() + 1; j++)
		{
			pnOutput[i + j - 1] += pnNum1[i] * pnNum2[j] + nPre;
			nPre = pnOutput[i + j - 1] / 10;
			pnOutput[i + j - 1] %= 10;
		}
		pnOutput[szNum2.length() + i] = nPre;
		nPre = 0;
	}

	nOutputLen = szNum1.length() + szNum2.length();
	while (pnOutput[nOutputLen] == 0 && nOutputLen > 1)
		nOutputLen--;

	for (int i = nOutputLen; i >= 1; i--)
		printf("%d", pnOutput[i]);

Exit0:
	return 0;
}
```

## P1480 A/B Problem

**题目描述**

输入两个整数a,b，输出它们的商(a<=10^5000,b<=10^9)

**输入格式**

两行，第一行是被除数，第二行是除数。

**输出格式**

一行，商的整数部分

**输入输出样例**

```c++
/////////////////////////////////////////////

//
//	FileName	:	First.cpp
//	Creator		:	Fm
//	Date		:	2019-9-29 18:28
//	Comment		:	OJ(P1480)
//
///////////////////////////////////////////


//#include "pch.h"
#include <iostream>
#include <cstdio>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stack>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <list>
#include <map>

using namespace std;
#define	MAXNUM		10010
#define	EPS         0.0001
#define MODNUM		100003


typedef unsigned char       BYTE;
typedef int                 BOOL;
typedef unsigned long       DWORD;




int main(int argc, char* argv[])
{
	string			szNum1;
	int				nNum2;
	int				nPre					= 0;
	list<int>		lsNum;

	cin >> szNum1 >> nNum2;

	if (szNum1.length() <= 9)
		printf("%d", atoi(szNum1.c_str()) / nNum2);
	else
	{
		for (int i = 0; i < szNum1.length(); i++)
			szNum1[i] -= '0';
		for (int i = 0; i < szNum1.length(); i++)
		{
			lsNum.push_back((szNum1[i] + nPre * 10) / nNum2);
			nPre = (szNum1[i] + nPre * 10) % nNum2;
		}
		while (lsNum.front() == 0)
			lsNum.pop_front();
		while (!lsNum.empty())
		{
			printf("%d", lsNum.front());
			lsNum.pop_front();
		}
			

	}
	

Exit0:
	return 0;
}
```

